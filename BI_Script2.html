  <!-- #region agent log - Check if BI_Script2 is in the page -->
  <script>console.log('[DEBUG-BS2-PRESENT] BI_Script2.html IS included in page');</script>
  <!-- #endregion -->
  <script>
    // #region agent log
    console.log('[DEBUG-G] BI_Script2.html script block STARTED parsing at', new Date().toISOString());
    // #endregion
    // =========================================================
    // --- KNOWLEDGE HUB CHAT FUNCTIONS ---
    // =========================================================
    
    /**
     * COLUMN CATEGORIES - Maps section names to column ranges
     * Mirrors the backend COLUMN_CATEGORIES for client-side column rotation
     */
    const COLUMN_CATEGORIES = {
      'ACCOUNT_IDS': { name: 'Account IDs', columns: ['E'] },
      'ACCOUNT_NAME': { name: 'Account Name', columns: ['G'] },
      'LOCATION': { name: 'Location', columns: ['I'] },
      'DATES_ACTIVITY': { name: 'Dates & Activity', columns: ['J', 'K', 'L'] },
      'ACCOUNT_STATUS': { name: 'Account + Status Info', columns: ['M', 'N', 'O'] },
      'SYSTEM_STATS': { name: 'System Stats', columns: ['P', 'Q', 'R'] },
      'PERCENTAGE_METRICS': { name: 'Percentage Metrics', columns: ['S', 'T', 'U'] },
      'REVENUE': { name: 'Revenue', columns: ['V', 'W', 'X'] },
      'SEATED_COVERS': { name: 'Seated Covers', columns: ['Y', 'Z', 'AA'] },
      'PRICING': { name: 'Pricing', columns: ['AB', 'AC', 'AD'] }
    };
    
    const khState = {
      isOpen: false,
      isLoading: false,
      currentRequestId: null,    // Tracks current request ID for abort handling
      conversationHistory: [],
      pendingColumnAction: null,    // Stores {category: 'DATES_ACTIVITY', metric: 'Customer Since'}
      pendingFunctionAction: null,  // Stores {functionName: 'manualUpdateNotesOnly', label: 'Refresh Notes'}
      pendingSlackAction: null,     // Stores {channel: 'ask-intouch'} for Slack escalation
      pendingSmartSelectAction: null, // Stores {rids: ['12345', '67890', ...]} for checking RIDs
      pendingTeamAnalysisAction: false, // True when team analysis is pending
      pendingRetryQuery: null,      // Stores query to retry after navigating to AM tab
      currentAMContext: null,       // Stores {isAMTab, fullName, isTeamView, sheetName}
      modifiedColumns: {},          // Tracks which columns were modified this session
      lastModifiedMetric: null,     // Tracks last modified metric for filtering advice context
      lastListedRIDs: null,         // Stores RIDs from the last list response for "add them" follow-ups
      autoIsolateMode: false,       // True when query started with "isolate" or "filter" - triggers auto check+filter
      showResetButton: false,       // True after auto-isolate to show Reset button alongside Focus20
      isolatedRIDs: null,           // Stores currently isolated RIDs for layered filtering
      shouldLogNextChat: true,      // Log first chat after session/sidebar/newchat/expand - then reset
      // Daily Jump Start state
      jumpStartData: null,          // Cached data from getJumpStartData()
      jumpStartLoading: false,      // Loading state for Jump Start
      expandedSections: {},         // Tracks which sections are expanded {termPending: true, ...}
      // Free Google Cohort state
      freeGoogleData: null,         // Cached data from getFreeGoogleCohortData()
      freeGoogleLoading: false,     // Loading state for Free Google panel
      expandedFreeGoogleCohorts: {}, // Tracks which cohorts are expanded
      lastCopiedFreeGoogleRID: null, // Last RID copied from Free Google panel
      lastCopiedFreeGoogleAccount: null, // Account data for last copied RID
      pendingFreeGoogleStrategy: null, // Pending strategy request {rid, accountData, cohortName, play}
      // Pre-fetched AM data for faster chat responses
      cachedAMData: null,           // Cached portfolio data from getDetailedAMData()
      cachedAMDataExpiry: 0,        // Timestamp when cached data expires
      cachedAMDataTime: null,       // Date object when data was fetched (for display)
      currentAMName: null           // Current AM name for refresh functionality
    };
    
    // Confirmation phrases that trigger pending column action
    const CONFIRMATION_PHRASES = [
      'yes', 'yeah', 'ya', 'yep', 'yup', 'sure', 'ok', 'okay', 'go for it', 
      'do it', 'please', 'go ahead', 'sounds good', 'let\'s do it', 'make it so',
      'absolutely', 'definitely', 'of course', 'yes please', 'that would be great',
      'perfect', 'great', 'cool', 'awesome', 'proceed', 'confirmed', 'affirmative'
    ];

    const khEls = {
      panel: null,
      clearBtn: null,
      stopBtn: null,
      helpBtn: null,
      messages: null,
      input: null,
      sendBtn: null,
      welcome: null
    };

    function initKnowledgeHub() {
      // #region agent log
      console.log('[DEBUG-A] initKnowledgeHub CALLED at', new Date().toISOString());
      // #endregion
      // Tab-based layout - no FAB or minimize needed
      khEls.panel = document.getElementById('tab-bucket-iq');
      khEls.clearBtn = document.getElementById('khClear');
      khEls.stopBtn = document.getElementById('khStop');
      khEls.helpBtn = document.getElementById('helpBtn');
      khEls.messages = document.getElementById('khMessages');
      khEls.input = document.getElementById('khInput');
      khEls.sendBtn = document.getElementById('khSend');
      khEls.welcome = document.getElementById('khWelcome');

      // #region agent log
      console.log('[DEBUG-B] DOM elements found:', {
        panel: !!khEls.panel,
        clearBtn: !!khEls.clearBtn,
        stopBtn: !!khEls.stopBtn,
        helpBtn: !!khEls.helpBtn,
        messages: !!khEls.messages,
        input: !!khEls.input,
        sendBtn: !!khEls.sendBtn,
        welcome: !!khEls.welcome
      });
      // #endregion

      // Wire up button click handlers
      if (khEls.clearBtn) khEls.clearBtn.addEventListener('click', clearKHChat);
      if (khEls.stopBtn) khEls.stopBtn.addEventListener('click', stopKHRequest);
      if (khEls.helpBtn) khEls.helpBtn.addEventListener('click', showHelpGuide);
      if (khEls.sendBtn) khEls.sendBtn.addEventListener('click', sendKHMessage);

      // Suggestion clicks
      document.querySelectorAll('.kh-suggestion').forEach(btn => {
        btn.addEventListener('click', () => {
          if (khEls.input) {
            khEls.input.value = btn.textContent;
            sendKHMessage();
          }
        });
      });

      // Enter key to send (Ctrl+Enter or Cmd+Enter for textarea)
      if (khEls.input) {
        khEls.input.addEventListener('keydown', (e) => {
          // Send on Enter (without Shift for new line)
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendKHMessage();
          }
        });
      }

      // #region agent log
      console.log('[DEBUG-A] initKnowledgeHub COMPLETE - event listeners attached');
      // #endregion

      // Initialize AM context on load (chat is now always visible in tab)
      initAMContext();
    }
    
    function clearKHChat() {
      // Reset conversation state
      khState.conversationHistory = [];
      
      // Log first chat after new chat clicked
      khState.shouldLogNextChat = true;
      khState.isLoading = false;
      khState.currentRequestId = null;
      khState.pendingColumnAction = null;
      khState.pendingFunctionAction = null;
      khState.pendingSlackAction = null;
      khState.pendingSmartSelectAction = null;
      khState.pendingTeamAnalysisAction = false;
      khState.currentAMContext = null;
      khState.modifiedColumns = {};
      khState.lastListedRIDs = null;
      khState.autoIsolateMode = false;
      khState.showResetButton = false;
      khState.isolatedRIDs = null;
      // Reset Jump Start state
      khState.jumpStartData = null;
      khState.jumpStartLoading = false;
      khState.expandedSections = {};
      
      // Clear messages and show welcome screen
      if (khEls.messages) {
        khEls.messages.innerHTML = `
          <!-- Daily Jump Start Accordion -->
          <div class="kh-jumpstart" id="khJumpStart" style="display:none;">
            <div class="kh-jumpstart-header">
              <div class="kh-jumpstart-title-wrapper">
                <div class="kh-jumpstart-title">
                  <span>üåÖ<\/span> DAILY JUMP START
                <\/div>
                <div class="kh-jumpstart-am-indicator" id="khJumpStartAM"><\/div>
              <\/div>
              <button class="kh-jumpstart-refresh" onclick="startMyDay()" title="Refresh">
                üîÑ
              <\/button>
            <\/div>
            <div id="khJumpStartContent">
              <!-- Sections will be injected here -->
            <\/div>
          <\/div>
          <!-- Daily Insights rendered separately to avoid clipping -->
          <div id="khJumpStartInsights"><\/div>

          <div class="kh-welcome" id="khWelcome">
            <div class="kh-welcome-icon">‚ú¶<\/div>
            <h5>Let's Get Down To Buckets<\/h5>
            <p>Features, Metrics, Nasty Saves, Support, I've GOT YOUR BACK!<\/p>
            
            <button class="kh-jumpstart-trigger" onclick="startMyDay()">
              <span>üåÖ<\/span> Start My Day
            <\/button>
            <div class="kh-section-label">InTouch Help<\/div>
            <div class="kh-suggestions">
              <button class="kh-suggestion kh-top-prompt">What can you do?<\/button>
              <button class="kh-suggestion">How does iQ scoring work?<\/button>
              <button class="kh-suggestion">Help me build my Focus20 list<\/button>
              <button class="kh-suggestion">Sheet looks broken<\/button>
              <button class="kh-suggestion">What should I look at first?<\/button>
            <\/div>
            <div class="kh-section-label">Account Analysis<\/div>
            <div class="kh-suggestions">
              <button class="kh-suggestion">Summarize my bucket<\/button>
              <button class="kh-suggestion">Flag accounts I haven't touched in 60+ days<\/button>
              <button class="kh-suggestion">Who is up for renewal soon?<\/button>
              <button class="kh-suggestion">Show my Icons and Elites<\/button>
              <button class="kh-suggestion">Which accounts should I pitch PI to?<\/button>
              <button class="kh-suggestion">How do I rank against the team?<\/button>
            <\/div>
          <\/div>
        `;
        
        // Re-wire suggestion buttons
        document.querySelectorAll('.kh-suggestion').forEach(btn => {
          btn.addEventListener('click', () => {
            if (khEls.input) {
              khEls.input.value = btn.textContent;
              sendKHMessage();
            }
          });
        });
        // Note: New Chat and Help buttons are now in bucket-iq-input-area (outside khMessages)
        // so they don't need to be re-wired when clearing the chat
      }
      
      // Update welcome reference
      khEls.welcome = document.getElementById('khWelcome');
      
      // Clear input and reset buttons
      if (khEls.input) {
        khEls.input.value = '';
        khEls.input.focus();
      }
      
      // Reset send/stop buttons
      if (khEls.stopBtn) khEls.stopBtn.style.display = 'none';
      if (khEls.sendBtn) {
        khEls.sendBtn.style.display = 'inline-flex';
        khEls.sendBtn.disabled = false;
      }
    }

    // =========================================================
    // --- DAILY JUMP START FUNCTIONS ---
    // =========================================================
    
    /**
     * Truncate account name for display
     * @param {string} name - Account name
     * @param {number} maxLength - Maximum length (default 28)
     * @returns {string} Truncated name with '...' if needed
     */
    function truncateAccountName(name, maxLength = 28) {
      if (!name) return '';
      if (name.length <= maxLength) return name;
      return name.substring(0, maxLength - 3) + '...';
    }
    
    /**
     * Start My Day - Main entry point for Daily Jump Start
     * Fetches data and renders the accordion
     */
    function startMyDay() {
      console.log('[startMyDay] Starting...');
      
      // EDGE CASE 8: Debounce rapid clicks - prevent multiple fetches
      if (khState.jumpStartLoading) {
        console.log('[startMyDay] Already loading, ignoring click');
        return;
      }
      
      // Get DOM elements
      const jumpStartEl = document.getElementById('khJumpStart');
      const jumpStartContent = document.getElementById('khJumpStartContent');
      const welcomeEl = document.getElementById('khWelcome');
      const triggerBtn = document.querySelector('.kh-jumpstart-trigger');
      const refreshBtn = document.querySelector('.kh-jumpstart-refresh');
      
      if (!jumpStartEl || !jumpStartContent) {
        console.error('[startMyDay] Jump Start elements not found');
        return;
      }
      
      // Show accordion, hide welcome
      jumpStartEl.style.display = 'block';
      if (welcomeEl) welcomeEl.style.display = 'none';
      
      // EDGE CASE 2: Loading state - disable buttons to prevent double-clicks
      khState.jumpStartLoading = true;
      if (triggerBtn) triggerBtn.disabled = true;
      if (refreshBtn) refreshBtn.disabled = true;
      
      // Show loading spinner
      jumpStartContent.innerHTML = `
        <div class="kh-jumpstart-loading">
          <div class="kh-loading-dots">
            <span><\/span><span><\/span><span><\/span>
          <\/div>
          <div class="kh-jumpstart-loading-text">
            Loading your priorities...
          <\/div>
        <\/div>
      `;
      
      // Get AM name from context or let server detect
      const amName = (khState.currentAMContext && khState.currentAMContext.fullName) || '';
      
      google.script.run
        .withSuccessHandler((result) => {
          console.log('[startMyDay] Data received:', result);
          
          // Re-enable buttons
          khState.jumpStartLoading = false;
          if (triggerBtn) triggerBtn.disabled = false;
          if (refreshBtn) refreshBtn.disabled = false;
          
          if (result.success) {
            // EDGE CASE 7: Reset expand state on refresh (fresh start)
            khState.jumpStartData = result;
            khState.expandedSections = {};
            renderJumpStartAccordion(result);
          } else {
            // EDGE CASE 3: Error state with friendly message and retry
            console.error('[startMyDay] Server returned error:', result.error);
            jumpStartContent.innerHTML = `
              <div class="kh-jumpstart-error">
                <div class="kh-jumpstart-error-icon">‚ö†Ô∏è<\/div>
                <div class="kh-jumpstart-error-text">
                  Couldn't load your daily summary
                <\/div>
                <div class="kh-jumpstart-error-detail">
                  ${result.error || 'Please try again'}
                <\/div>
                <button class="kh-jumpstart-btn primary" onclick="startMyDay()">
                  Try Again
                <\/button>
              <\/div>
            `;
          }
        })
        .withFailureHandler((error) => {
          // EDGE CASE 3: Network/server error handling
          console.error('[startMyDay] Fetch error:', error);
          
          // Re-enable buttons
          khState.jumpStartLoading = false;
          if (triggerBtn) triggerBtn.disabled = false;
          if (refreshBtn) refreshBtn.disabled = false;
          
          jumpStartContent.innerHTML = `
            <div class="kh-jumpstart-error">
              <div class="kh-jumpstart-error-icon">‚ùå<\/div>
              <div class="kh-jumpstart-error-text">
                Connection error
              <\/div>
              <div class="kh-jumpstart-error-detail">
                ${error.message || 'Please check your connection and try again'}
              <\/div>
              <button class="kh-jumpstart-btn primary" onclick="startMyDay()">
                Try Again
              <\/button>
            <\/div>
          `;
        })
        .getJumpStartData(amName);
    }
    
    /**
     * Render the Jump Start accordion with all sections
     * Handles threshold behavior: 0 (empty), 1-6 (expanded), 7+ (collapsed)
     * @param {Object} data - Data from getJumpStartData()
     */
    // Section tooltip definitions - natural language descriptions of qualifiers
    const sectionTooltips = {
      termPending: 'Accounts with status indicating termination or cancellation in progress',
      contractsExpiring: 'Accounts with contracts ending within the next 45 days',
      noEngagement60: 'Accounts with no logged engagement in the last 60+ days',
      noBookings30: 'Accounts with No Bookings >30 Days flags (0-Fullbook, No Booking, etc.)',
      nonOTSystem: 'Accounts using a non-OpenTable System of Record (Resy, SevenRooms, etc.)',
      highPIRevenue: 'Accounts with PI Rev Share >30% AND Rev Yield - Total Last Month >$1,200'
    };
    
    function renderJumpStartAccordion(data) {
      const jumpStartContent = document.getElementById('khJumpStartContent');
      if (!jumpStartContent || !data.sections) {
        console.error('[renderJumpStartAccordion] Missing content element or sections');
        return;
      }
      
      // Update AM indicator in header
      const amIndicator = document.getElementById('khJumpStartAM');
      if (amIndicator && data.amName) {
        amIndicator.textContent = `üìä ${data.amName} (${data.totalAccounts} accounts)`;
        amIndicator.style.display = 'inline-block';
      }
      
      // Define section order (priority: high ‚Üí medium ‚Üí opportunity)
      const sectionOrder = ['termPending', 'contractsExpiring', 'noEngagement60', 'noBookings30', 'nonOTSystem', 'highPIRevenue'];
      
      let html = '';
      let totalAccounts = 0;
      
      sectionOrder.forEach(sectionId => {
        const section = data.sections[sectionId];
        if (!section) return;
        
        const count = section.count;
        
        // Skip sections with zero results - don't display them at all
        if (count === 0) return;
        
        totalAccounts += count;
        
        // EDGE CASE 6: Threshold behavior
        // 1-6 accounts: auto-expanded with list + buttons
        // 7+ accounts: collapsed by default, "Show All" button
        const isLargeSection = count > 6;
        
        // Determine expansion state
        let expanded = '';
        if (khState.expandedSections[sectionId] === undefined) {
          // First render: auto-expand 1-6, collapse 7+
          khState.expandedSections[sectionId] = !isLargeSection;
        }
        expanded = khState.expandedSections[sectionId] ? 'expanded' : '';
        
        const sectionTooltip = sectionTooltips[sectionId] || '';
        
        html += `
          <div class="kh-jumpstart-section ${expanded}" data-section-id="${sectionId}" data-count="${count}">
            <div class="kh-jumpstart-section-header" onclick="toggleJumpStartSection('${sectionId}')">
              <span class="kh-jumpstart-chevron">‚ñ∂<\/span>
              <span class="kh-jumpstart-dot">${section.priorityDot}<\/span>
              <span class="kh-jumpstart-name" onmouseenter="showCustomTooltip(this, '${sectionTooltip}')" onmouseleave="hideCustomTooltip()">${section.title}<\/span>
              <span class="kh-jumpstart-badge ${section.priority === 'high' ? 'urgent' : ''}">${count}<\/span>
            <\/div>
            <div class="kh-jumpstart-content">
              ${renderSectionContent(section, isLargeSection)}
            <\/div>
          <\/div>
        `;
      });
      
      // All clear state when no accounts need attention
      if (totalAccounts === 0) {
        html = `
          <div class="kh-jumpstart-all-clear">
            <div class="kh-jumpstart-all-clear-icon">‚ú®<\/div>
            <div class="kh-jumpstart-all-clear-text">All clear!<\/div>
            <div class="kh-jumpstart-all-clear-subtext">No accounts need immediate attention<\/div>
          <\/div>
        `;
      }
      
      jumpStartContent.innerHTML = html;
      
      // Render Strategic Insights to separate container (outside accordion to avoid clipping)
      const insightsContainer = document.getElementById('khJumpStartInsights');
      if (insightsContainer) {
        let insightsHtml = '';
        
        if (data.strategicInsights) {
          const suggestions = data.strategicInsights.suggestions || [];
          const prompts = data.strategicInsights.recommendedPrompts || [];
          
          if (suggestions.length > 0 || prompts.length > 0) {
            insightsHtml = `
              <div class="kh-jumpstart-insights">
                <div class="kh-jumpstart-insights-header">
                  <span class="kh-jumpstart-insights-icon">üí°<\/span>
                  <span>Daily Insights<\/span>
                <\/div>
                ${suggestions.length > 0 ? `
                  <div class="kh-jumpstart-strategic">
                    <strong>Strategic Focus:<\/strong>
                    ${suggestions.map(s => `<div class="kh-jumpstart-suggestion">‚Ä¢ ${s}<\/div>`).join('')}
                  <\/div>
                ` : ''}
                ${prompts.length > 0 ? `
                  <div class="kh-jumpstart-prompts">
                    <strong>Try asking:<\/strong>
                    ${prompts.map(p => `<button class="kh-suggested-prompt" onclick="insertPrompt('${escapeHtml(p)}')">${p}<\/button>`).join('')}
                  <\/div>
                ` : ''}
              <\/div>
            `;
          }
        }
        
        insightsContainer.innerHTML = insightsHtml;
      }
      
      console.log(`[renderJumpStartAccordion] Rendered ${sectionOrder.length} sections, ${totalAccounts} total accounts`);
    }
    
    /**
     * Insert a suggested prompt into the chat input and optionally send it
     * @param {string} prompt - The prompt text to insert
     */
    function insertPrompt(prompt) {
      if (khEls.input) {
        khEls.input.value = prompt;
        khEls.input.focus();
        // Optionally auto-send - uncomment to send immediately
        // sendKHMessage();
      }
    }
    
    /**
     * Escape HTML special characters for safe insertion
     * @param {string} text - Text to escape
     * @returns {string} Escaped text
     */
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML.replace(/'/g, "\\'");
    }
    
    /**
     * Get color class for days since engagement
     * @param {number} daysSince - Days since last engagement (999 = no date)
     * @returns {string} CSS class name
     */
    function getDaysColorClass(daysSince) {
      if (daysSince === 999) return 'days-red';     // No date = +90D
      if (daysSince <= 45) return 'days-green';
      if (daysSince <= 75) return 'days-orange';
      return 'days-red';                            // 76-90+
    }
    
    /**
     * Render content for a section with accounts
     * EDGE CASE 6: Handles threshold behavior for large sections (7+)
     * @param {Object} section - Section data with accounts array
     * @param {boolean} isLargeSection - True if section has 7+ accounts (collapsed by default)
     * @returns {string} HTML string
     */
    function renderSectionContent(section, isLargeSection = false) {
      if (!section.accounts || section.accounts.length === 0) {
        return renderEmptySection();
      }
      
      const count = section.accounts.length;
      
      // Check if this section has subsections (e.g., noBookings30 with flag groups)
      let listHtml = '';
      
      if (section.subsections && section.subsections.length > 0) {
        // Render with subsection headers for each flag type
        listHtml = '<div class="kh-jumpstart-list">';
        
        section.subsections.forEach((subsection, subIdx) => {
          // Add subsection header with flag name and count
          listHtml += `
            <div class="kh-jumpstart-subsection">
              <div class="kh-jumpstart-subsection-header">
                <span class="kh-jumpstart-subsection-flag">${subsection.flag}<\/span>
                <span class="kh-jumpstart-subsection-count">${subsection.count}<\/span>
              <\/div>
          `;
          
          // Render accounts in this subsection (show first 3 per subsection)
          const displayAccounts = subsection.accounts.slice(0, 3);
          displayAccounts.forEach(acc => {
            const name = truncateAccountName(acc.name);
            const emojiHtml = acc.emoji ? `<span class="kh-emoji-tag">${acc.emoji}<\/span>` : '';
            
            listHtml += `
              <div class="kh-jumpstart-row">
                <span class="kh-jumpstart-emoji">${emojiHtml}<\/span>
                <span class="kh-jumpstart-acc-name" onmouseenter="showCustomTooltip(this, 'Click to copy RID: ${acc.rid}')" onmouseleave="hideCustomTooltip()" data-rid="${acc.rid}" onclick="copyRIDToClipboard('${acc.rid}')">${name}<\/span>
              <\/div>
            `;
          });
          
          // Show "and X more" if there are more accounts in this subsection
          if (subsection.accounts.length > 3) {
            listHtml += `<div class="kh-jumpstart-row" style="font-size: 10px; color: #94a3b8; padding-left: 20px;">...and ${subsection.accounts.length - 3} more<\/div>`;
          }
          
          listHtml += '<\/div>';  // Close subsection
        });
        
        listHtml += '<\/div>';  // Close list
      } else {
        // Standard rendering without subsections
        listHtml = '<div class="kh-jumpstart-list">';
        section.accounts.forEach((acc, idx) => {
          const name = truncateAccountName(acc.name);
          
          // Render emoji tags inline with individual hover labels (using custom tooltip)
          let emojiHtml = '';
          if (acc.emojiTags && acc.emojiTags.length > 0) {
            emojiHtml = acc.emojiTags
              .map(tag => `<span class="kh-emoji-tag" onmouseenter="showCustomTooltip(this, '${tag.label}')" onmouseleave="hideCustomTooltip()">${tag.emoji}<\/span>`)
              .join('');
          } else if (acc.emoji) {
            // Fallback to old format if emojiTags not available
            emojiHtml = `<span class="kh-emoji-tag">${acc.emoji}<\/span>`;
          }
          
          // Build days label based on section type
          let daysHtml = '';
          if (section.id === 'contractsExpiring' && acc.daysUntil != null) {
            daysHtml = `<span class="kh-days-label">${acc.daysUntil}D<\/span>`;
          } else if (section.id === 'noEngagement60' && acc.daysSince != null) {
            const daysDisplay = acc.daysSince === 999 ? '+90D' : `${acc.daysSince}D`;
            const colorClass = getDaysColorClass(acc.daysSince);
            daysHtml = `<span class="kh-days-label ${colorClass}">${daysDisplay}<\/span>`;
          }
          
          // Add SOR type for nonOTSystem section
          let sorHtml = '';
          if (section.id === 'nonOTSystem' && acc.sorType) {
            sorHtml = `<span class="kh-days-label" style="background: #fef3c7; color: #92400e;">${acc.sorType}<\/span>`;
          }
          
          listHtml += `
            <div class="kh-jumpstart-row">
              <span class="kh-jumpstart-emoji">${emojiHtml}<\/span>
              <span class="kh-jumpstart-acc-name" onmouseenter="showCustomTooltip(this, 'Click to copy RID: ${acc.rid}')" onmouseleave="hideCustomTooltip()" data-rid="${acc.rid}" onclick="copyRIDToClipboard('${acc.rid}')">${name}<\/span>
              ${daysHtml}${sorHtml}
            <\/div>
          `;
        });
        listHtml += '<\/div>';
      }
      
      // Build action buttons with hover tooltips (using custom tooltip)
      const actionsHtml = `
        <div class="kh-jumpstart-actions">
          <button class="kh-jumpstart-btn" onclick="jumpStartIsolate('${section.id}')" onmouseenter="showCustomTooltip(this, 'Filter Smart Select to show only these accounts')" onmouseleave="hideCustomTooltip()">
            üéØ Isolate
          <\/button>
          <button class="kh-jumpstart-btn primary" onclick="jumpStartDigIn('${section.id}')" onmouseenter="showCustomTooltip(this, 'Isolate accounts and generate AI analysis')" onmouseleave="hideCustomTooltip()">
            üîç Dig In
          <\/button>
          <button class="kh-jumpstart-btn" onclick="jumpStartGlean('${section.id}')" id="gleanBtn-${section.id}" onmouseenter="showCustomTooltip(this, 'Copy prompt to clipboard and open Glean')" onmouseleave="hideCustomTooltip()">
            üß† Glean
          <\/button>
        <\/div>
      `;
      
      // EDGE CASE 6: For collapsed large sections (7+), show "Show All" prompt
      // This appears when section is collapsed, inviting user to expand
      const showAllHtml = isLargeSection ? `
        <div class="kh-jumpstart-show-all">
          <button class="kh-jumpstart-show-all-btn" onclick="expandJumpStartSection('${section.id}')">
            üìã Show All ${count} Accounts
          <\/button>
        <\/div>
      ` : '';
      
      return showAllHtml + listHtml + actionsHtml;
    }
    
    /**
     * Render empty section placeholder
     * @returns {string} HTML string
     */
    function renderEmptySection() {
      return `<div class="kh-jumpstart-empty">‚úÖ No accounts need attention<\/div>`;
    }
    
    /**
     * Toggle expand/collapse for a section
     * EDGE CASE 1: Empty sections (count=0) are not expandable
     * @param {string} sectionId - Section identifier
     */
    function toggleJumpStartSection(sectionId) {
      const sectionEl = document.querySelector(`[data-section-id="${sectionId}"]`);
      if (!sectionEl) return;
      
      // EDGE CASE 1: Don't allow toggle on empty sections
      const count = parseInt(sectionEl.dataset.count || '0');
      if (count === 0) {
        console.log(`[toggleJumpStartSection] Section ${sectionId} is empty, not expandable`);
        return;
      }
      
      const isExpanded = sectionEl.classList.contains('expanded');
      
      if (isExpanded) {
        // Collapse this section
        sectionEl.classList.remove('expanded');
        khState.expandedSections[sectionId] = false;
      } else {
        // ACCORDION BEHAVIOR: Collapse all other sections first
        document.querySelectorAll('.kh-jumpstart-section.expanded').forEach(el => {
          el.classList.remove('expanded');
          const id = el.dataset.sectionId;
          if (id) khState.expandedSections[id] = false;
        });
        
        // Then expand this one
        sectionEl.classList.add('expanded');
        khState.expandedSections[sectionId] = true;
      }
    }
    
    /**
     * Explicitly expand a section (used by "Show All" button)
     * EDGE CASE 6: For 7+ account sections, clicking "Show All" expands
     * @param {string} sectionId - Section identifier
     */
    function expandJumpStartSection(sectionId) {
      const sectionEl = document.querySelector(`[data-section-id="${sectionId}"]`);
      if (!sectionEl) return;
      
      sectionEl.classList.add('expanded');
      khState.expandedSections[sectionId] = true;
      console.log(`[expandJumpStartSection] Expanded section ${sectionId}`);
    }
    
    /**
     * Silent isolation - same as executeAutoIsolate but returns promise, no chat message
     * Used by Dig In to isolate first, then show a single combined message
     * @param {Array} rids - Array of RID strings to isolate
     * @returns {Promise<Object>} - Resolves with {success, checkedCount, isolatedRIDs, ...}
     */
    function executeAutoIsolateSilent(rids) {
      return new Promise((resolve, reject) => {
        // Validate input
        if (!rids || rids.length === 0) {
          resolve({ success: false, error: 'No RIDs to isolate' });
          return;
        }
        
        // Get AM context for the server call
        const amName = khState.currentAMContext ? khState.currentAMContext.fullName : '';
        const isLayering = khState.isolatedRIDs && khState.isolatedRIDs.length > 0;
        
        console.log(`[executeAutoIsolateSilent] ${isLayering ? 'LAYERING' : 'FRESH'}: ${rids.length} RIDs`);
        
        // Choose appropriate server function based on whether we're layering
        const serverFunction = isLayering ? 'layerSmartSelectFilter' : 'checkAndFilterSmartSelect';
        
        // Build the server call dynamically
        if (isLayering) {
          // Layering: pass new RIDs, existing RIDs, and AM name
          google.script.run
            .withSuccessHandler((result) => {
              // Store isolated RIDs for future layering
              if (result.success) {
                khState.isolatedRIDs = result.isolatedRIDs || rids;
              }
              resolve(result);
            })
            .withFailureHandler((error) => {
              reject(error);
            })
            .layerSmartSelectFilter(rids, khState.isolatedRIDs, amName);
        } else {
          // Fresh isolation: just RIDs and AM name
          google.script.run
            .withSuccessHandler((result) => {
              // Store isolated RIDs for future layering
              if (result.success) {
                khState.isolatedRIDs = result.isolatedRIDs || rids;
              }
              resolve(result);
            })
            .withFailureHandler((error) => {
              reject(error);
            })
            .checkAndFilterSmartSelect(rids, amName);
        }
      });
    }
    
    /**
     * Isolate accounts in Smart Select (Jump Start action)
     * Uses existing executeAutoIsolate which handles its own messaging
     * @param {string} sectionId - Section identifier (e.g., 'termPending')
     */
    function jumpStartIsolate(sectionId) {
      // Validate section exists in cached data
      if (!(khState.jumpStartData && khState.jumpStartData.sections && khState.jumpStartData.sections[sectionId])) {
        console.error('[jumpStartIsolate] Section not found:', sectionId);
        addKHMessage('error', 'Section data not loaded. Try refreshing.');
        return;
      }
      
      const section = khState.jumpStartData.sections[sectionId];
      const rids = section.accounts.map(a => a.rid);
      
      // Handle empty section
      if (rids.length === 0) {
        addKHMessage('assistant', `No accounts to isolate in **${section.title}**.`);
        return;
      }
      
      console.log(`[jumpStartIsolate] Isolating ${rids.length} RIDs from ${sectionId}`);
      
      // Store pending action (for state tracking)
      khState.pendingSmartSelectAction = { rids };
      
      // Delegate to existing executeAutoIsolate - it handles:
      // - Loading state
      // - Server call
      // - Success/error messaging
      // - Focus20 + Reset button setup
      executeAutoIsolate(rids, sectionId);  // Pass sectionId as dataIndicator for tracking
    }
    
    /**
     * Dig In - Isolate silently, then show ONE combined message with strategic summary
     * @param {string} sectionId - Section identifier
     */
    function jumpStartDigIn(sectionId) {
      // Validate section exists in cached data
      if (!(khState.jumpStartData && khState.jumpStartData.sections && khState.jumpStartData.sections[sectionId])) {
        console.error('[jumpStartDigIn] Section not found:', sectionId);
        addKHMessage('error', 'Section data not loaded. Try refreshing.');
        return;
      }
      
      const section = khState.jumpStartData.sections[sectionId];
      const rids = section.accounts.map(a => a.rid);
      
      // Handle empty section
      if (rids.length === 0) {
        addKHMessage('assistant', `No accounts in **${section.title}** to analyze.`);
        return;
      }
      
      console.log(`[jumpStartDigIn] Digging into ${rids.length} accounts from ${sectionId}`);
      
      // Show loading state
      khState.isLoading = true;
      if (khEls.sendBtn) khEls.sendBtn.disabled = true;
      const loadingEl = addKHMessage('loading', '');
      
      // Use silent isolation - no automatic message
      executeAutoIsolateSilent(rids)
        .then((result) => {
          // Remove loading indicator
          if (loadingEl) loadingEl.remove();
          khState.isLoading = false;
          if (khEls.sendBtn) khEls.sendBtn.disabled = false;
          
          if (result.success) {
            // Build the ONE combined message with strategic summary
            const summary = generateDigInSummary(section, result.checkedCount, sectionId);
            
            // Set up Focus20 action for the button
            khState.pendingFunctionAction = {
              functionName: 'moveTrueAccountsToFocus20',
              label: 'Add to Focus20'
            };
            
            // Enable Reset button
            khState.showResetButton = true;
            
            // Output single combined message with action buttons
            addKHMessage('assistant', summary, true);
            
          } else if (result.wrongTab) {
            // User is on wrong AM tab
            addKHMessage('assistant', 
              `**Heads up:** You're not on the correct tab.\n\n` +
              `Expected: **${result.expectedTab}**\n` +
              `Current: **${result.currentTab || 'unknown'}**\n\n` +
              `Please navigate to the correct tab and try again.`
            );
          } else if (result.noIntersection) {
            // Layering resulted in no matches
            addKHMessage('assistant', 
              `**No matching accounts found.**\n\n` +
              `None of the ${section.title} accounts overlap with your current filter.\n\n` +
              `Click **Reset** to clear filters and try again.`
            );
            khState.showResetButton = true;
            khState.pendingFunctionAction = null;
            addKHMessage('assistant', '', true);  // Show reset button
          } else {
            // Generic error
            addKHMessage('error', result.error || 'Could not isolate accounts. Please try again.');
          }
        })
        .catch((error) => {
          // Handle promise rejection
          if (loadingEl) loadingEl.remove();
          khState.isLoading = false;
          if (khEls.sendBtn) khEls.sendBtn.disabled = false;
          addKHMessage('error', 'Error: ' + (error.message || 'Unknown error'));
        });
    }
    
    /**
     * Generate strategic summary message for Dig In based on section type
     * @param {Object} section - Section data with accounts array
     * @param {number} isolatedCount - Number of accounts actually isolated
     * @param {string} sectionId - Section identifier for strategic focus
     * @returns {string} Formatted markdown summary
     */
    function generateDigInSummary(section, isolatedCount, sectionId) {
      // Header with isolation confirmation
      let summary = `üîç **Digging into ${section.title}** (${isolatedCount} accounts)\n\n`;
      summary += `‚úÖ Sheet filtered to these accounts\n\n`;
      
      // Strategic summary varies by section type
      summary += getStrategicSummary(sectionId, section) + '\n\n';
      
      // Account list (top 5 with details)
      summary += `**Accounts:**\n`;
      section.accounts.slice(0, 5).forEach(acc => {
        const emoji = acc.emoji || '';
        const name = truncateAccountName(acc.name, 25);
        summary += `‚Ä¢ ${emoji} **${name}** (${acc.rid})`;
        
        // Add context based on section type
        if (sectionId === 'noEngagement60' && acc.daysSince) {
          summary += ` ‚Äî ${acc.daysSince}d since contact`;
        } else if (sectionId === 'noBookings30' && acc.reason) {
          summary += ` ‚Äî ${acc.reason}`;
        } else if (sectionId === 'nonOTSystem' && acc.sorType) {
          summary += ` ‚Äî SOR: ${acc.sorType}`;
        } else if (sectionId === 'highPIRevenue') {
          if (acc.piShare) summary += ` ‚Äî PI: ${acc.piShare}`;
          if (acc.revenue) summary += `, Rev: ${acc.revenue}`;
        }
        summary += '\n';
      });
      
      // Show overflow count
      if (section.accounts.length > 5) {
        summary += `‚Ä¢ _...and ${section.accounts.length - 5} more_\n`;
      }
      
      // CTA for next action
      
      return summary;
    }
    
    /**
     * Get strategic summary content based on section type
     * @param {string} sectionId - Section identifier
     * @param {Object} section - Section data
     * @returns {string} Strategic guidance text
     */
    function getStrategicSummary(sectionId, section) {
      const count = section.accounts.length;
      
      switch (sectionId) {
        case 'termPending':
          return `${section.priorityDot} **Renewal Urgency**\n` +
            `These ${count} accounts have terms pending/expired. Priority actions:\n` +
            `‚Ä¢ Review each contract status in column K (Term End Date)\n` +
            `‚Ä¢ Check for competitive threats before outreach\n` +
            `‚Ä¢ Prepare renewal proposals with any applicable upsells\n` +
            `‚Ä¢ _Consider escalating accounts with > $1K monthly revenue_`;
            
        case 'contractsExpiring':
          return `${section.priorityDot} **Expiration Timeline**\n` +
            `These ${count} accounts are approaching contract end. Strategy:\n` +
            `‚Ä¢ Prioritize by revenue and churn risk\n` +
            `‚Ä¢ Document competitive intel from recent conversations\n` +
            `‚Ä¢ Identify upsell opportunities (PI, Experiences, etc.)\n` +
            `‚Ä¢ _30-day window is ideal for renewal conversations_`;
            
        case 'noEngagement60':
          return `${section.priorityDot} **Re-engagement Priority**\n` +
            `These ${count} accounts haven't been contacted in 60+ days:\n` +
            `‚Ä¢ Check last engagement date in column L\n` +
            `‚Ä¢ Review recent performance metrics for conversation starters\n` +
            `‚Ä¢ Watch for churn signals (declining covers, disco issues)\n` +
            `‚Ä¢ _Quick check-in calls can prevent silent churn_`;
            
        case 'noBookings30':
          return `${section.priorityDot} **Booking Investigation**\n` +
            `These ${count} accounts have booking issues to investigate:\n` +
            `‚Ä¢ Check availability settings and inventory\n` +
            `‚Ä¢ Review seasonal patterns vs. anomalies\n` +
            `‚Ä¢ Look for operational issues (closed days, staffing)\n` +
            `‚Ä¢ _0-Fullbook often indicates setup problems, not demand issues_`;
            
        case 'nonOTSystem':
          return `${section.priorityDot} **System of Record Risk**\n` +
            `These ${count} accounts use a non-OpenTable system of record:\n` +
            `‚Ä¢ Identify the primary reservation system (Resy, SevenRooms, etc.)\n` +
            `‚Ä¢ Assess competitive exposure and switching risk\n` +
            `‚Ä¢ Look for integration friction points affecting OT usage\n` +
            `‚Ä¢ _Consider Operational Relief Play if system issues exist_`;
            
        case 'highPIRevenue':
          return `${section.priorityDot} **Revenue Optimization**\n` +
            `These ${count} accounts have strong PI traction (>30% share, >$1.2K rev):\n` +
            `‚Ä¢ Review PI campaign performance in DISTRO\n` +
            `‚Ä¢ Identify optimization opportunities (bid adjustments, targeting)\n` +
            `‚Ä¢ Consider upsell to higher PI tiers or Experiences\n` +
            `‚Ä¢ _These are your high-ROI accounts ‚Äî nurture the relationship_`;
            
        default:
          return `${section.priorityDot} **${section.title}**\n` +
            `${count} accounts flagged for review.`;
      }
    }
    
    /**
     * Glean - Copy comprehensive prompt to clipboard and open Glean
     * @param {string} sectionId - Section identifier
     */
    function jumpStartGlean(sectionId) {
      // Validate section exists
      if (!(khState.jumpStartData && khState.jumpStartData.sections && khState.jumpStartData.sections[sectionId])) {
        console.error('[jumpStartGlean] Section not found:', sectionId);
        addKHMessage('error', 'Section data not loaded. Try refreshing.');
        return;
      }
      
      const section = khState.jumpStartData.sections[sectionId];
      const amName = khState.jumpStartData.amName || 'Account Manager';
      
      // Handle empty section
      if (section.accounts.length === 0) {
        addKHMessage('assistant', `No accounts in **${section.title}** to analyze with Glean.`);
        return;
      }
      
      console.log(`[jumpStartGlean] Generating Glean prompt for ${section.accounts.length} accounts`);
      
      // Get the button for visual feedback
      const gleanBtn = document.getElementById(`gleanBtn-${sectionId}`);
      const originalText = gleanBtn ? gleanBtn.innerHTML : '';
      
      // Generate the comprehensive Glean prompt
      const prompt = generateGleanPrompt(section, amName, sectionId);
      
      // Copy to clipboard and open Glean
      navigator.clipboard.writeText(prompt)
        .then(() => {
          // EDGE CASE 9: Visual feedback on button
          if (gleanBtn) {
            gleanBtn.innerHTML = '‚úì Copied';
            gleanBtn.classList.add('copied');
            
            // Reset button text after 2 seconds
            setTimeout(() => {
              gleanBtn.innerHTML = originalText;
              gleanBtn.classList.remove('copied');
            }, 2000);
          }
          
          // Open Glean in new tab
          window.open('https:\/\/app.glean.com\/', '_blank');
          
          // Silent operation - visual feedback is already on the button ("‚úì Copied")
          console.log(`[jumpStartGlean] Prompt copied to clipboard, opening Glean for ${section.accounts.length} accounts`);
        })
        .catch((err) => {
          console.error('[jumpStartGlean] Clipboard error:', err);
          addKHMessage('error', 'Could not copy to clipboard. Please try again.');
        });
    }
    
    /**
     * Get Salesforce fields to query based on section type
     * @param {string} sectionId - Section identifier
     * @returns {Array} Array of SF field names/descriptions
     */
    function getSalesforceFields(sectionId) {
      const baseFields = [
        'Account Name, Hidden ID, Finance Systems ID',
        'Owner, Account Manager, Account Executive',
        'CQ Account Tier, Customer Type, Account Status',
        'Primary Product, Restaurant Product Type',
        'Vitality Score, Reputation Score, Visibility Score',
        'Churn Probability, Churn Probability Month, Churn Probability Reason',
        'Days since last activity, Engagement Status',
        'Active_Contract__r (contract ID + name)',
        'Current Payment Status, Collections Status'
      ];
      
      const sectionFields = {
        termPending: [
          ...baseFields,
          'Most_Recent_Termination_Case__r (case status)',
          'Most_Recent_Collections_Notice__r',
          'System_of_Record__r (competitor lookup)',
          'Business Status (open, permanently closed)',
          'Related Opportunities ‚Äî Stage, Close Date'
        ],
        
        contractsExpiring: [
          ...baseFields,
          'Auto Renewal, Auto Renewal Term, Auto Renewal Changed Date',
          'Account on Month to Month Renewal',
          'Customer Since, Customer For',
          'Related Opportunities ‚Äî Renewal pipeline',
          'Related Cases ‚Äî open issues'
        ],
        
        noEngagement60: [
          ...baseFields,
          'Days since last activity (critical ‚Äî confirm 60+)',
          'Contact: Last Activity, Most Recent Activity Type, Number of Tasks Associated',
          'Related Cases ‚Äî filed during silence period',
          'Slack threads ‚Äî internal discussions about this account'
        ],
        
        noBookings30: [
          ...baseFields,
          'Primary Product, Contracted Primary Product',
          'System_of_Record__r (are they OT primary?)',
          'Restaurant Status, Business Status',
          'Related Cases ‚Äî technical/integration issues',
          'Jira ‚Äî any related bugs or feature requests'
        ],
        
        nonOTSystem: [
          ...baseFields,
          'System_of_Record__r (Competitor lookup ‚Äî critical)',
          'Customer Type (Listing Only = competitor primary)',
          'Intended System of Record (at sale) on Opportunities',
          'System Change Type on Opportunities',
          'Vitality Score (low = limited OT engagement)'
        ],
        
        highPIRevenue: [
          ...baseFields,
          'Chase Status, Chase - Tier',
          'Current Charges',
          'Related Campaigns ‚Äî membership and performance',
          'Related Opportunities ‚Äî upsell, tier upgrade',
          'Prospect Tier on Opportunities'
        ]
      };
      
      return sectionFields[sectionId] || baseFields;
    }
    
    /**
     * Get additional (non-SF) data sources to search based on section type
     * @param {string} sectionId - Section identifier
     * @returns {Array} Array of data source descriptions
     */
    function getAdditionalSources(sectionId) {
      const baseSources = [
        'Slack ‚Äî internal threads mentioning restaurant name',
        'Gmail ‚Äî your email correspondence',
        'Google Calendar ‚Äî meetings and QBRs'
      ];
      
      const sectionSources = {
        termPending: [
          ...baseSources,
          'Slack ‚Äî escalation threads, save discussions',
          'Zoom transcripts ‚Äî recent calls about retention',
          'Drive/Confluence ‚Äî save playbooks, retention strategies'
        ],
        
        contractsExpiring: [
          ...baseSources,
          'Slack ‚Äî renewal discussions',
          'Drive ‚Äî renewal strategy docs, QBR materials',
          'Zoom transcripts ‚Äî recent account reviews'
        ],
        
        noEngagement60: [
          ...baseSources,
          'Gmail ‚Äî last inbound email from restaurant',
          'Calendar ‚Äî scheduled meetings that may have been missed',
          'Slack ‚Äî any internal flags or concerns'
        ],
        
        noBookings30: [
          ...baseSources,
          'Jira ‚Äî technical issues, integration bugs',
          'Confluence ‚Äî troubleshooting guides, integration docs',
          'Slack ‚Äî #support or technical channels'
        ],
        
        nonOTSystem: [
          ...baseSources,
          'Slack ‚Äî competitive intel, migration discussions',
          'Drive/Confluence ‚Äî competitive playbooks',
          'Zoom transcripts ‚Äî discovery calls about their workflow'
        ],
        
        highPIRevenue: [
          ...baseSources,
          'Drive ‚Äî campaign performance docs',
          'Slack ‚Äî marketing/PI discussions',
          'Confluence ‚Äî PI program documentation'
        ]
      };
      
      return sectionSources[sectionId] || baseSources;
    }
    
    /**
     * Get relevant timeframe for analysis based on section type
     * @param {string} sectionId - Section identifier
     * @returns {string} Timeframe description
     */
    function getRelevantTimeframe(sectionId) {
      const timeframes = {
        termPending: 'the past 6 months (emphasize last 30 days)',
        contractsExpiring: 'the past 90 days',
        noEngagement60: '90 days before silence began + any activity since',
        noBookings30: 'the past 60 days',
        nonOTSystem: 'the past 6 months',
        highPIRevenue: 'the past 90 days'
      };
      return timeframes[sectionId] || 'the past 30 days';
    }
    
    /**
     * Generate comprehensive Glean prompt with section-specific focus (V4)
     * Includes data source guidance, Salesforce field mappings, timeframes, and structured output
     * @param {Object} section - Section data with accounts array
     * @param {string} amName - AM's full name
     * @param {string} sectionId - Section identifier for customization
     * @returns {string} Formatted prompt for Glean
     */
    function generateGleanPrompt(section, amName, sectionId) {
      const timeframe = getRelevantTimeframe(sectionId);
      const sfFields = getSalesforceFields(sectionId);
      const additionalSources = getAdditionalSources(sectionId);
      
      let prompt = `## OBJECTIVE\n`;
      prompt += `Analyze ${section.accounts.length} restaurant accounts for [[Account Manager: ${amName}]] flagged as "${section.title}" and provide actionable next steps.\n\n`;
      
      // Data sources - calibrated to what actually works
      prompt += `## DATA SOURCES TO SEARCH\n\n`;
      prompt += `**Salesforce (Primary):**\n`;
      prompt += `‚Ä¢ Accounts, Contacts, Opportunities, Cases, Campaigns\n`;
      prompt += `‚Ä¢ Note: Tasks only available as aggregates on Contacts; Contracts only via Active_Contract__r lookup\n\n`;
      prompt += `**Additional Sources:**\n`;
      additionalSources.forEach(source => {
        prompt += `‚Ä¢ ${source}\n`;
      });
      prompt += `\n`;
      
      // Timeframe
      prompt += `## TIMEFRAME\n`;
      prompt += `Focus on activity from ${timeframe}.\n\n`;
      
      // Salesforce fields with REAL names
      prompt += `## SALESFORCE FIELDS TO QUERY\n`;
      sfFields.forEach(field => {
        prompt += `‚Ä¢ ${field}\n`;
      });
      prompt += `\n`;
      
      // Focus area
      prompt += `## FOCUS AREA\n`;
      prompt += getGleanFocusV4(sectionId) + '\n\n';
      
      // Account list with correct ID fields
      prompt += `## ACCOUNTS TO ANALYZE\n`;
      prompt += `| Restaurant | Hidden ID | Finance Systems ID | Key Signal |\n`;
      prompt += `|------------|-----------|-------------------|------------|\n`;
      section.accounts.forEach(acc => {
        // Build key signal from available fields
        let signal = '‚Äî';
        if (acc.reason) {
          signal = acc.reason;
        } else if (acc.daysSince) {
          signal = `${acc.daysSince}d since activity`;
        } else if (acc.daysUntil) {
          signal = `${acc.daysUntil}d until expiration`;
        } else if (acc.piShare && acc.revenue) {
          signal = `PI: ${acc.piShare}, Rev: ${acc.revenue}`;
        } else if (acc.sorType) {
          signal = `SOR: ${acc.sorType}`;
        }
        prompt += `| ${acc.name} | ${acc.rid} | FS${acc.rid} | ${signal} |\n`;
      });
      prompt += `\n`;
      
      // Search guidance
      prompt += `## SEARCH GUIDANCE\n`;
      prompt += `For each account:\n`;
      prompt += `1. Search Salesforce by **Account Name** or **Hidden ID**\n`;
      prompt += `2. Pull related Contacts (check RID field), Opportunities (check Account RID)\n`;
      prompt += `3. Check for Cases, especially Most_Recent_Termination_Case__r\n`;
      prompt += `4. Search Slack for threads mentioning the restaurant name\n`;
      prompt += `5. Search Gmail/Calendar for recent correspondence\n\n`;
      
      // Output format
      prompt += `## OUTPUT FORMAT\n`;
      prompt += `For each account:\n\n`;
      prompt += `**[Restaurant Name]** (Hidden ID: XXX | Finance Systems ID: FSXXX)\n`;
      prompt += `‚Ä¢ **Owner**: [Owner] | **AM**: [Account Manager] | **AE**: [Account Executive]\n`;
      prompt += `‚Ä¢ **Segment**: [CQ Account Tier] | [Customer Type] | [Restaurant Product Type]\n`;
      prompt += `‚Ä¢ **Health**: Vitality: X | Reputation: X | Visibility: X\n`;
      prompt += `‚Ä¢ **Risk**: Churn Probability: X% ‚Äî [Churn Probability Reason if available]\n`;
      prompt += `‚Ä¢ **Engagement**: [Days since last activity] days | Status: [Engagement Status]\n`;
      prompt += `‚Ä¢ **Contract**: [Active_Contract__r name] | Auto Renewal: [Yes/No] | M2M: [Yes/No]\n`;
      prompt += `‚Ä¢ **Billing**: [Current Payment Status] | Collections: [Yes/No]\n`;
      prompt += `‚Ä¢ **Recent Comms**: [Slack threads, emails, meetings found]\n`;
      prompt += `‚Ä¢ **Open Items**: [Cases, Opportunities]\n`;
      prompt += `‚Ä¢ **‚ö†Ô∏è Risk Signals**: [Flag urgent items]\n`;
      prompt += `‚Ä¢ **Recommended Action**: [Specific next step with timeframe]\n\n`;
      prompt += `End with **Priority Ranking** (1-${section.accounts.length}) by Churn Probability and business impact.\n`;
      
      return prompt;
    }
    
    /**
     * Get section-specific focus text for Glean prompt (V4)
     * Includes objective, SF search, Slack search, other sources, and red flags
     * @param {string} sectionId - Section identifier
     * @returns {string} Focus area description
     */
    function getGleanFocusV4(sectionId) {
      const focusTemplates = {
        termPending: {
          objective: `Identify save opportunities for accounts pending termination.`,
          sfSearch: [
            `Check Churn Probability and Churn Probability Reason fields`,
            `Pull Most_Recent_Termination_Case__r ‚Äî status, type, priority`,
            `Check Current Payment Status, Collections Status, Most_Recent_Collections_Notice__r`,
            `Look at System_of_Record__r ‚Äî are they on a competitor?`,
            `Check Business Status ‚Äî open vs permanently closed`,
            `Pull Days since last activity ‚Äî when was last contact?`
          ],
          slackSearch: [
            `Search for threads mentioning this restaurant name`,
            `Look for escalation discussions or save attempts`,
            `Check for competitor mentions (Resy, Yelp, SevenRooms, Tock)`
          ],
          otherSearch: [
            `Gmail ‚Äî threads with "cancel", "terminate", or competitor names`,
            `Drive/Confluence ‚Äî save playbooks for similar situations`,
            `Zoom ‚Äî recent call transcripts`
          ],
          redFlags: [
            `Churn Probability > 0.5`,
            `Days since last activity > 60`,
            `Current Payment Status = "Past Due" or "Send to Collections"`,
            `System_of_Record__r shows competitor`,
            `Business Status = "permanently closed" or "possibly closed"`
          ]
        },
        
        contractsExpiring: {
          objective: `Prepare renewal strategy for accounts with expiring contracts.`,
          sfSearch: [
            `Pull Active_Contract__r ‚Äî ID and name`,
            `Check Auto Renewal, Auto Renewal Term, Account on Month to Month Renewal`,
            `Look for open Renewal Opportunities ‚Äî Stage, Close Date, Amount`,
            `Check Days since last activity and Engagement Status`,
            `Pull CQ Account Tier for pricing context`,
            `Check Current Payment Status ‚Äî billing issues block renewals`
          ],
          slackSearch: [
            `Search for renewal discussions mentioning this account`,
            `Look for pricing or negotiation threads`,
            `Check for competitive threat mentions`
          ],
          otherSearch: [
            `Gmail ‚Äî recent correspondence about contract or renewal`,
            `Calendar ‚Äî upcoming meetings scheduled`,
            `Drive ‚Äî QBR materials, account plans`
          ],
          redFlags: [
            `No Renewal Opportunity exists`,
            `Auto Renewal = false with no recent engagement`,
            `Days since last activity > 30`,
            `Churn Probability increasing`,
            `Open Cases with no resolution`
          ]
        },
        
        noEngagement60: {
          objective: `Diagnose engagement gaps and identify re-activation paths.`,
          sfSearch: [
            `Confirm Days since last activity > 60`,
            `Check Engagement Status ‚Äî expect "No Engagement"`,
            `Pull Contact: Last Activity, Most Recent Activity Type, Number of Tasks Associated`,
            `Look for Cases filed during silence period`,
            `Check Churn Probability trend`
          ],
          slackSearch: [
            `Search for any internal discussion about this account`,
            `Look for flags or concerns raised by team members`,
            `Check if ownership changed recently`
          ],
          otherSearch: [
            `Gmail ‚Äî last inbound email from restaurant`,
            `Calendar ‚Äî scheduled meetings that didn't happen`,
            `Zoom ‚Äî any recent call transcripts`
          ],
          redFlags: [
            `Days since last activity > 90`,
            `Contact: Number of Tasks Associated is high but no response`,
            `Owner or Account Manager changed recently`,
            `No Slack or email activity found`
          ]
        },
        
        noBookings30: {
          objective: `Identify booking blockers and operational issues.`,
          sfSearch: [
            `Check Primary Product and Restaurant Product Type`,
            `Pull System_of_Record__r ‚Äî are they OT primary?`,
            `Look at Restaurant Status and Business Status`,
            `Search for Cases ‚Äî technical or integration issues`,
            `Check Customer Type ‚Äî Listing Only indicates limited integration`
          ],
          slackSearch: [
            `Search #support or technical channels for this account`,
            `Look for integration or availability issues`,
            `Check for discussions about booking problems`
          ],
          otherSearch: [
            `Jira ‚Äî bugs or feature requests mentioning this RID/account`,
            `Confluence ‚Äî integration guides, troubleshooting docs`,
            `Gmail ‚Äî technical support threads`
          ],
          redFlags: [
            `System_of_Record__r shows competitor as primary`,
            `Customer Type = "Listing Only"`,
            `Open Case tagged technical/integration`,
            `Restaurant Status = "Inactive"`,
            `Very low Vitality Score`
          ]
        },
        
        nonOTSystem: {
          objective: `Assess consolidation opportunity for accounts using competitor systems.`,
          sfSearch: [
            `Pull System_of_Record__r ‚Äî which competitor? (critical)`,
            `Check Customer Type ‚Äî "Listing Only" confirms competitor primary`,
            `Look at Primary Product vs Contracted Primary Product`,
            `Search Opportunities for Intended System of Record (at sale), System Change Type`,
            `Check Vitality Score ‚Äî low indicates limited OT usage`
          ],
          slackSearch: [
            `Search for competitive discussions about this account`,
            `Look for migration or consolidation conversations`,
            `Check for pain points mentioned with their current system`
          ],
          otherSearch: [
            `Drive/Confluence ‚Äî competitive playbooks`,
            `Zoom ‚Äî discovery call transcripts about their workflow`,
            `Gmail ‚Äî discussions about integration or migration`
          ],
          redFlags: [
            `System_of_Record__r clearly shows competitor`,
            `No migration Opportunity in pipeline`,
            `Very low Vitality Score (< 30)`,
            `Customer Type = "Listing Only" with no upgrade Opp`
          ]
        },
        
        highPIRevenue: {
          objective: `Maximize PI ROI and identify upsell opportunities.`,
          sfSearch: [
            `Pull Chase Status, Chase - Tier`,
            `Check Current Charges for spend level`,
            `Search Campaigns for PI membership and performance metrics`,
            `Look for Opportunities ‚Äî upsell, tier upgrade`,
            `Check CQ Account Tier ‚Äî upgrade potential?`
          ],
          slackSearch: [
            `Search for PI or marketing discussions about this account`,
            `Look for budget or ROI conversations`,
            `Check for campaign performance mentions`
          ],
          otherSearch: [
            `Drive ‚Äî campaign reports, performance analyses`,
            `Confluence ‚Äî PI program documentation`,
            `Gmail ‚Äî budget discussions`
          ],
          redFlags: [
            `No upsell Opportunity despite high spend`,
            `Declining Vitality or Visibility scores`,
            `Chase Status changed to ineligible`,
            `Campaign metrics showing declining performance`
          ]
        }
      };
      
      const template = focusTemplates[sectionId] || {
        objective: `Analyze accounts for patterns and recommended actions.`,
        sfSearch: ['Standard Account and Contact fields'],
        slackSearch: ['Threads mentioning restaurant name'],
        otherSearch: ['Gmail, Calendar, Drive'],
        redFlags: ['High Churn Probability', 'No recent engagement']
      };
      
      let output = `**Objective:** ${template.objective}\n\n`;
      
      output += `**Salesforce Search:**\n`;
      template.sfSearch.forEach(item => {
        output += `‚Ä¢ ${item}\n`;
      });
      
      output += `\n**Slack Search:**\n`;
      template.slackSearch.forEach(item => {
        output += `‚Ä¢ ${item}\n`;
      });
      
      output += `\n**Other Sources:**\n`;
      template.otherSearch.forEach(item => {
        output += `‚Ä¢ ${item}\n`;
      });
      
      output += `\n**Red Flags to Surface:**\n`;
      template.redFlags.forEach(flag => {
        output += `‚Ä¢ ‚ö†Ô∏è ${flag}\n`;
      });
      
      return output;
    }

    // =============================================================
    // FREE GOOGLE COHORT PANEL FUNCTIONS
    // =============================================================
    
    /**
     * Start Free Google cohort exploration
     * Loads cohort data and renders accordion
     */
    function startFreeGoogle() {
      console.log('[startFreeGoogle] Starting...');
      
      // Debounce rapid clicks
      if (khState.freeGoogleLoading) {
        console.log('[startFreeGoogle] Already loading, ignoring click');
        return;
      }
      
      // Get DOM elements
      const freeGoogleEl = document.getElementById('khFreeGoogle');
      const freeGoogleContent = document.getElementById('khFreeGoogleContent');
      const welcomeEl = document.getElementById('khWelcome');
      const jumpStartEl = document.getElementById('khJumpStart');
      const triggerBtns = document.querySelectorAll('.kh-freegoogle-trigger');
      const refreshBtn = freeGoogleEl ? freeGoogleEl.querySelector('.kh-jumpstart-refresh') : null;
      
      if (!freeGoogleEl || !freeGoogleContent) {
        console.error('[startFreeGoogle] Free Google elements not found');
        return;
      }
      
      // Show Free Google panel, hide welcome and Jump Start
      freeGoogleEl.style.display = 'block';
      if (welcomeEl) welcomeEl.style.display = 'none';
      if (jumpStartEl) jumpStartEl.style.display = 'none';
      
      // Hide jump start insights too
      const jumpStartInsights = document.getElementById('khJumpStartInsights');
      if (jumpStartInsights) jumpStartInsights.innerHTML = '';
      
      // Loading state
      khState.freeGoogleLoading = true;
      triggerBtns.forEach(btn => btn.disabled = true);
      if (refreshBtn) refreshBtn.disabled = true;
      
      // Show loading spinner
      freeGoogleContent.innerHTML = `
        <div class="kh-jumpstart-loading">
          <div class="kh-loading-dots">
            <span><\/span><span><\/span><span><\/span>
          <\/div>
          <div class="kh-jumpstart-loading-text">
            Loading Free Google cohorts...
          <\/div>
        <\/div>
      `;
      
      google.script.run
        .withSuccessHandler((result) => {
          console.log('[startFreeGoogle] Data received:', result);
          
          // Re-enable buttons
          khState.freeGoogleLoading = false;
          triggerBtns.forEach(btn => btn.disabled = false);
          if (refreshBtn) refreshBtn.disabled = false;
          
          if (result.success) {
            // Store data for later use
            khState.freeGoogleData = result;
            khState.expandedFreeGoogleCohorts = {};
            renderFreeGoogleAccordion(result);
          } else {
            console.error('[startFreeGoogle] Server returned error:', result.error);
            freeGoogleContent.innerHTML = `
              <div class="kh-jumpstart-error">
                <div class="kh-jumpstart-error-icon">‚ö†Ô∏è<\/div>
                <div class="kh-jumpstart-error-text">
                  Couldn't load Free Google data
                <\/div>
                <div class="kh-jumpstart-error-detail">
                  ${result.error || 'Please try again'}
                <\/div>
                <button class="kh-jumpstart-btn primary" onclick="startFreeGoogle()">
                  Try Again
                <\/button>
              <\/div>
            `;
          }
        })
        .withFailureHandler((error) => {
          console.error('[startFreeGoogle] Fetch error:', error);
          
          // Re-enable buttons
          khState.freeGoogleLoading = false;
          triggerBtns.forEach(btn => btn.disabled = false);
          if (refreshBtn) refreshBtn.disabled = false;
          
          freeGoogleContent.innerHTML = `
            <div class="kh-jumpstart-error">
              <div class="kh-jumpstart-error-icon">‚ùå<\/div>
              <div class="kh-jumpstart-error-text">
                Connection error
              <\/div>
              <div class="kh-jumpstart-error-detail">
                ${error.message || 'Please check your connection and try again'}
              <\/div>
              <button class="kh-jumpstart-btn primary" onclick="startFreeGoogle()">
                Try Again
              <\/button>
            <\/div>
          `;
        })
        .getFreeGoogleCohortData();
    }
    
    /**
     * Render Free Google cohort accordion
     * @param {Object} data - Data from getFreeGoogleCohortData()
     */
    function renderFreeGoogleAccordion(data) {
      const freeGoogleContent = document.getElementById('khFreeGoogleContent');
      if (!freeGoogleContent || !data.cohorts) {
        console.error('[renderFreeGoogleAccordion] Missing content element or cohorts');
        return;
      }
      
      // Update total indicator
      const totalIndicator = document.getElementById('khFreeGoogleTotal');
      if (totalIndicator) {
        totalIndicator.textContent = `üìä ${data.totalAccounts} accounts`;
        totalIndicator.style.display = 'inline-block';
      }
      
      // Get cohort order from config (already sorted by server)
      const cohortOrder = Object.keys(data.cohorts);
      
      let html = '';
      let totalAccounts = 0;
      
      cohortOrder.forEach(cohortName => {
        const cohort = data.cohorts[cohortName];
        if (!cohort || cohort.count === 0) return;
        
        totalAccounts += cohort.count;
        
        // Determine expansion state (first cohort expanded by default)
        const isLargeCohort = cohort.count > 10;
        if (khState.expandedFreeGoogleCohorts[cohort.id] === undefined) {
          khState.expandedFreeGoogleCohorts[cohort.id] = !isLargeCohort && totalAccounts === cohort.count;
        }
        const expanded = khState.expandedFreeGoogleCohorts[cohort.id] ? 'expanded' : '';
        
        html += `
          <div class="kh-jumpstart-section ${expanded}" data-cohort-id="${cohort.id}" data-count="${cohort.count}">
            <div class="kh-jumpstart-section-header" onclick="toggleFreeGoogleCohort('${cohort.id}')">
              <span class="kh-jumpstart-chevron">‚ñ∂<\/span>
              <span class="kh-jumpstart-dot">${cohort.priorityDot}<\/span>
              <span class="kh-jumpstart-name">${cohort.title} <span style="color:#64748b;font-weight:400;">(${cohort.play})<\/span><\/span>
              <span class="kh-jumpstart-badge">${cohort.count}<\/span>
            <\/div>
            <div class="kh-jumpstart-content">
              ${renderFreeGoogleCohortContent(cohort, isLargeCohort)}
            <\/div>
          <\/div>
        `;
      });
      
      // Empty state
      if (totalAccounts === 0) {
        html = `
          <div class="kh-jumpstart-all-clear">
            <div class="kh-jumpstart-all-clear-icon">üìã<\/div>
            <div class="kh-jumpstart-all-clear-text">No Free Google accounts<\/div>
            <div class="kh-jumpstart-all-clear-subtext">No accounts in the Free Google cohorts<\/div>
          <\/div>
        `;
      }
      
      freeGoogleContent.innerHTML = html;
      
      // Render insights
      const insightsContainer = document.getElementById('khFreeGoogleInsights');
      if (insightsContainer && totalAccounts > 0) {
        insightsContainer.innerHTML = `
          <div class="kh-jumpstart-insights">
            <div class="kh-jumpstart-insights-header">
              <span class="kh-jumpstart-insights-icon">üí°<\/span>
              <span>Free Google Guidance<\/span>
            <\/div>
            <div class="kh-jumpstart-strategic">
              <strong>How to use:<\/strong>
              <div class="kh-jumpstart-suggestion">‚Ä¢ Click any account name to copy its RID<\/div>
              <div class="kh-jumpstart-suggestion">‚Ä¢ Paste the RID in chat for a tailored strategy<\/div>
              <div class="kh-jumpstart-suggestion">‚Ä¢ Choose Quick Strategy, Full Strategy, or Glean handoff<\/div>
            <\/div>
          <\/div>
        `;
      }
      
      console.log(`[renderFreeGoogleAccordion] Rendered ${cohortOrder.length} cohorts, ${totalAccounts} total accounts`);
    }
    
    /**
     * Render content for a Free Google cohort
     * @param {Object} cohort - Cohort data with accounts array
     * @param {boolean} isLargeCohort - True if cohort has many accounts
     * @returns {string} HTML string
     */
    function renderFreeGoogleCohortContent(cohort, isLargeCohort = false) {
      if (!cohort.accounts || cohort.accounts.length === 0) {
        return `<div class="kh-jumpstart-empty">No accounts in this cohort<\/div>`;
      }
      
      const count = cohort.accounts.length;
      const displayLimit = isLargeCohort ? 10 : count;
      const displayAccounts = cohort.accounts.slice(0, displayLimit);
      
      let listHtml = '<div class="kh-jumpstart-list">';
      
      displayAccounts.forEach(acc => {
        const name = truncateAccountName(acc.name);
        const groupLabel = acc.category === 'Group' ? `<span style="color:#64748b;font-size:10px;margin-left:4px;">(Group)<\/span>` : '';
        const googleRPRBadge = acc.googleRPR > 0 ? `<span class="kh-days-label" style="background:#dcfce7;color:#166534;">$${Math.round(acc.googleRPR)}<\/span>` : '';
        
        listHtml += `
          <div class="kh-jumpstart-row">
            <span class="kh-jumpstart-acc-name" 
                  onmouseenter="showCustomTooltip(this, 'Click to copy RID: ${acc.rid}')" 
                  onmouseleave="hideCustomTooltip()" 
                  data-rid="${acc.rid}" 
                  onclick="copyFreeGoogleRID('${acc.rid}')">${name}${groupLabel}<\/span>
            ${googleRPRBadge}
          <\/div>
        `;
      });
      
      listHtml += '<\/div>';
      
      // Show "and X more" for large cohorts
      if (count > displayLimit) {
        listHtml += `
          <div class="kh-jumpstart-show-all">
            <button class="kh-jumpstart-show-all-btn" onclick="expandFreeGoogleCohort('${cohort.id}')">
              üìã Show All ${count} Accounts
            <\/button>
          <\/div>
        `;
      }
      
      return listHtml;
    }
    
    /**
     * Toggle expand/collapse for a Free Google cohort
     * @param {string} cohortId - Cohort identifier
     */
    function toggleFreeGoogleCohort(cohortId) {
      const cohortEl = document.querySelector(`[data-cohort-id="${cohortId}"]`);
      if (!cohortEl) return;
      
      const count = parseInt(cohortEl.dataset.count || '0');
      if (count === 0) {
        console.log(`[toggleFreeGoogleCohort] Cohort ${cohortId} is empty, not expandable`);
        return;
      }
      
      const isExpanded = cohortEl.classList.contains('expanded');
      
      if (isExpanded) {
        cohortEl.classList.remove('expanded');
        khState.expandedFreeGoogleCohorts[cohortId] = false;
      } else {
        // Accordion behavior: collapse all others first
        document.querySelectorAll('#khFreeGoogleContent .kh-jumpstart-section.expanded').forEach(el => {
          el.classList.remove('expanded');
          const id = el.dataset.cohortId;
          if (id) khState.expandedFreeGoogleCohorts[id] = false;
        });
        
        cohortEl.classList.add('expanded');
        khState.expandedFreeGoogleCohorts[cohortId] = true;
      }
    }
    
    /**
     * Expand a Free Google cohort (used by "Show All" button)
     * @param {string} cohortId - Cohort identifier
     */
    function expandFreeGoogleCohort(cohortId) {
      const cohortEl = document.querySelector(`[data-cohort-id="${cohortId}"]`);
      if (!cohortEl) return;
      
      // Re-render with all accounts
      const cohort = (khState.freeGoogleData && khState.freeGoogleData.cohorts) ? khState.freeGoogleData.cohorts[Object.keys(khState.freeGoogleData.cohorts).find(k => 
        khState.freeGoogleData.cohorts[k].id === cohortId
      )] : null;
      
      if (cohort) {
        const contentEl = cohortEl.querySelector('.kh-jumpstart-content');
        if (contentEl) {
          contentEl.innerHTML = renderFreeGoogleCohortContent(cohort, false);
        }
      }
      
      cohortEl.classList.add('expanded');
      khState.expandedFreeGoogleCohorts[cohortId] = true;
    }
    
    /**
     * Copy Free Google RID to clipboard with strategic guidance toast
     * @param {string} rid - Restaurant ID to copy
     */
    function copyFreeGoogleRID(rid) {
      // Find account data for context
      let accountData = null;
      if (khState.freeGoogleData && khState.freeGoogleData.cohorts) {
        for (const cohortName of Object.keys(khState.freeGoogleData.cohorts)) {
          const cohort = khState.freeGoogleData.cohorts[cohortName];
          const found = cohort.accounts.find(a => a.rid === rid);
          if (found) {
            accountData = { ...found, cohort: cohortName, play: cohort.play };
            break;
          }
        }
      }
      
      // Store for later detection when pasted
      khState.lastCopiedFreeGoogleRID = rid;
      khState.lastCopiedFreeGoogleAccount = accountData;
      
      navigator.clipboard.writeText(rid).then(() => {
        const toast = document.getElementById('khToast');
        if (toast) {
          toast.textContent = `RID ${rid} copied ‚Äî Paste in chat for strategic play`;
          toast.classList.add('show');
          setTimeout(() => toast.classList.remove('show'), 3000);
        }
      }).catch(err => {
        console.error('[copyFreeGoogleRID] Failed to copy:', err);
      });
    }
    
    /**
     * Check if input is a Free Google RID and show strategy options
     * @param {string} input - User input to check
     * @returns {boolean} True if handled as Free Google RID
     */
    function checkFreeGoogleRID(input) {
      const ridMatch = input.match(/^\d{5,8}$/);
      if (!ridMatch) return false;
      
      const rid = ridMatch[0];
      
      // Check if this RID is in our Free Google data
      if (!(khState.freeGoogleData && khState.freeGoogleData.cohorts)) return false;
      
      let accountData = null;
      let cohortName = null;
      
      for (const cName of Object.keys(khState.freeGoogleData.cohorts)) {
        const cohort = khState.freeGoogleData.cohorts[cName];
        const found = cohort.accounts.find(a => String(a.rid) === rid);
        if (found) {
          accountData = found;
          cohortName = cName;
          break;
        }
      }
      
      if (!accountData) return false;
      
      // This is a Free Google RID - show strategy options
      showFreeGoogleStrategyMenu(rid, accountData, cohortName);
      return true;
    }
    
    /**
     * Show strategy options menu for a Free Google account
     * @param {string} rid - Restaurant ID
     * @param {Object} accountData - Account data from Free Google sheet
     * @param {string} cohortName - Cohort name
     */
    function showFreeGoogleStrategyMenu(rid, accountData, cohortName) {
      const cohort = (khState.freeGoogleData && khState.freeGoogleData.cohorts) ? khState.freeGoogleData.cohorts[cohortName] : null;
      const play = (cohort && cohort.play) || 'Standard Evaluation';
      
      // Store for later use
      khState.pendingFreeGoogleStrategy = { rid, accountData, cohortName, play };
      
      // Build message with account context and options
      const googleRPR = accountData.googleRPR ? `$${Math.round(accountData.googleRPR)}/mo` : 'N/A';
      const piRPR = accountData.piRPR ? `$${Math.round(accountData.piRPR)}/mo` : 'N/A';
      const subDiscount = accountData.subDiscount ? `$${Math.round(accountData.subDiscount)}/mo` : 'N/A';
      
      const message = `**${accountData.name}** (RID: ${rid})

**Cohort:** ${cohortName}
**Recommended Play:** ${play}

| Metric | Value |
|--------|-------|
| Google RPR | ${googleRPR} |
| PI RPR | ${piRPR} |
| Sub Discount | ${subDiscount} |
| Contract | ${accountData.contractStatus || 'Unknown'} |

**What would you like?**`;

      addKHMessage('assistant', message);
      
      // Add action buttons
      const actionsHtml = `
        <div class="kh-action-buttons" style="margin-top: 8px; display: flex; gap: 8px; flex-wrap: wrap;">
          <button class="kh-action-btn primary" onclick="executeFreeGoogleStrategy('quick')">
            ‚ö° Quick Strategy
          <\/button>
          <button class="kh-action-btn" onclick="executeFreeGoogleStrategy('full')">
            üìã Full Strategy
          <\/button>
          <button class="kh-action-btn" onclick="executeFreeGoogleStrategy('glean')">
            üß† Take It to Glean
          <\/button>
        <\/div>
      `;
      
      // Append buttons to last message
      const messages = document.querySelectorAll('.kh-msg.assistant');
      const lastMsg = messages[messages.length - 1];
      if (lastMsg) {
        const contentEl = lastMsg.querySelector('.kh-msg-content');
        if (contentEl) {
          contentEl.insertAdjacentHTML('beforeend', actionsHtml);
        }
      }
    }
    
    /**
     * Execute Free Google strategy generation
     * @param {string} type - 'quick', 'full', or 'glean'
     */
    function executeFreeGoogleStrategy(type) {
      const pending = khState.pendingFreeGoogleStrategy;
      if (!pending) {
        addKHMessage('error', 'No account selected. Please copy an RID from the Free Google panel first.');
        return;
      }
      
      const { rid, accountData, cohortName, play } = pending;
      
      if (type === 'quick') {
        // Generate quick strategy inline
        generateQuickFreeGoogleStrategy(rid, accountData, cohortName, play);
      } else if (type === 'full') {
        // Send to AI for full strategy
        generateFullFreeGoogleStrategy(rid, accountData, cohortName, play);
      } else if (type === 'glean') {
        // Generate Glean prompt and open Glean
        executeFreeGoogleGlean(rid);
      }
      
      // Clear pending
      khState.pendingFreeGoogleStrategy = null;
    }
    
    /**
     * Generate quick tactical strategy for Free Google account
     */
    function generateQuickFreeGoogleStrategy(rid, accountData, cohortName, play) {
      const strategies = {
        'Discount Swap': {
          bullets: [
            `**Play:** Discount Swap ‚Äî Trade sub discount for Free Google + list pricing`,
            `**Core Ask:** New contract at list sub rate, Free Google included`,
            `**Prep:** Calculate sub discount vs Google revenue ‚Äî is there rebalancing room?`,
            `**Risk:** Partner may resist losing discount without clear value exchange`
          ]
        },
        'PI Booster': {
          bullets: [
            `**Play:** PI Booster ‚Äî Free Google in exchange for PI commitment`,
            `**Core Ask:** Commit to PI spend increase or minimum budget`,
            `**Prep:** Review current PI performance, identify campaigns to pitch`,
            `**Risk:** Partner may not see PI value; prepare ROI examples`
          ]
        },
        'Save At-Risk': {
          bullets: [
            `**Play:** Save At-Risk ‚Äî Free Google as renewal incentive`,
            `**Core Ask:** Sign renewal with term lock + Free Google`,
            `**Prep:** Confirm expiration date, check churn signals, review competitor mentions`,
            `**Risk:** Running out of time; prioritize urgently if <30 days`
          ]
        },
        'Hybrid': {
          bullets: [
            `**Play:** Hybrid ‚Äî Partial sub normalization + Free Google`,
            `**Core Ask:** Adjusted sub rate (not full list) plus Free Google`,
            `**Prep:** Model the middle ground ‚Äî what feels fair?`,
            `**Risk:** May need multiple conversations to find the balance`
          ]
        },
        'Standard Evaluation': {
          bullets: [
            `**Play:** Standard Evaluation ‚Äî Case-by-case assessment`,
            `**Core Ask:** Understand their situation before proposing`,
            `**Prep:** Review why they're in "Other" ‚Äî what's unique?`,
            `**Risk:** Free Google may not be the right fit; consider AYCE, Freemium, or UGC`
          ]
        }
      };
      
      const strategy = strategies[play] || strategies['Standard Evaluation'];
      
      let message = `**‚ö° Quick Strategy for ${accountData.name}**\n\n`;
      strategy.bullets.forEach(bullet => {
        message += `‚Ä¢ ${bullet}\n`;
      });
      
      message += `\n*Need more detail? Click "Full Strategy" or take it to Glean.*`;
      
      addKHMessage('assistant', message);
    }
    
    /**
     * Generate full strategy using AI
     */
    function generateFullFreeGoogleStrategy(rid, accountData, cohortName, play) {
      // Build prompt for AI
      const prompt = `Generate a Full Strategy for Free Google account:

**Account:** ${accountData.name} (RID: ${rid})
**Cohort:** ${cohortName}
**Play:** ${play}
**Google RPR:** $${Math.round(accountData.googleRPR || 0)}/mo
**PI RPR:** $${Math.round(accountData.piRPR || 0)}/mo
**Sub Discount:** $${Math.round(accountData.subDiscount || 0)}/mo
**Contract Status:** ${accountData.contractStatus || 'Unknown'}

Please provide:
1. Situation Assessment (1-2 sentences)
2. Recommended Play (1 sentence)
3. Priority Actions (2-3 bullets)
4. The Script (3-5 sentences talk track)
5. Watch Out For (1-2 bullets)`;

      // Show loading and send to AI
      addKHMessage('user', `Full Strategy for ${accountData.name}`);
      
      khState.isLoading = true;
      if (khEls.sendBtn) khEls.sendBtn.disabled = true;
      const loadingEl = addKHMessage('loading', '');
      
      // Get AM context
      const amName = (khState.currentAMContext && khState.currentAMContext.fullName) || '';
      
      google.script.run
        .withSuccessHandler((response) => {
          if (loadingEl) loadingEl.remove();
          khState.isLoading = false;
          if (khEls.sendBtn) khEls.sendBtn.disabled = false;
          
          if (response.success) {
            addKHMessage('assistant', response.response);
          } else {
            addKHMessage('error', response.error || 'Failed to generate strategy');
          }
        })
        .withFailureHandler((error) => {
          if (loadingEl) loadingEl.remove();
          khState.isLoading = false;
          if (khEls.sendBtn) khEls.sendBtn.disabled = false;
          addKHMessage('error', error.message || 'Failed to generate strategy');
        })
        .askInTouchGuide(prompt, amName);
    }
    
    /**
     * Execute Glean handoff for Free Google account
     */
    function executeFreeGoogleGlean(rid) {
      // Show loading
      const loadingEl = addKHMessage('loading', '');
      
      google.script.run
        .withSuccessHandler((result) => {
          if (loadingEl) loadingEl.remove();
          
          if (result.success) {
            // Copy prompt to clipboard
            navigator.clipboard.writeText(result.prompt)
              .then(() => {
                addKHMessage('assistant', `**‚úì Glean prompt copied for ${result.account.name}**

The prompt includes:
‚Ä¢ Account context and Free Google metrics
‚Ä¢ Salesforce field guidance (correct field names)
‚Ä¢ ${result.account.cohort}-specific research focus
‚Ä¢ Communication history search terms

Opening Glean now ‚Äî paste the prompt to begin research.`);
                
                // Open Glean
                window.open('https:\/\/app.glean.com\/', '_blank');
              })
              .catch((err) => {
                console.error('[executeFreeGoogleGlean] Clipboard error:', err);
                addKHMessage('error', 'Could not copy to clipboard. Please try again.');
              });
          } else {
            addKHMessage('error', result.error || 'Failed to generate Glean prompt');
          }
        })
        .withFailureHandler((error) => {
          if (loadingEl) loadingEl.remove();
          addKHMessage('error', error.message || 'Failed to generate Glean prompt');
        })
        .generateFreeGoogleGleanPrompt(rid);
    }

    // =============================================================
    // END FREE GOOGLE COHORT PANEL FUNCTIONS
    // =============================================================

    function sendKHMessage() {
      // #region agent log
      console.log('[DEBUG-C] sendKHMessage CALLED', {
        hasInput: !!khEls.input,
        inputValue: khEls.input ? khEls.input.value : '(null)',
        isLoading: khState.isLoading,
        timestamp: new Date().toISOString()
      });
      // #endregion
      if (!khEls.input) return;
      const query = khEls.input.value.trim();
      if (!query || khState.isLoading) {
        // #region agent log
        console.log('[DEBUG-C] sendKHMessage EARLY RETURN', { query: query, isLoading: khState.isLoading });
        // #endregion
        return;
      }

      // Hide welcome message
      if (khEls.welcome) {
        khEls.welcome.style.display = 'none';
      }

      // Check if this is a confirmation for a pending action
      const normalizedQuery = query.toLowerCase().trim();
      if (isConfirmationPhrase(normalizedQuery)) {
        if (khState.pendingColumnAction) {
          executeColumnAction(false); // false = triggered by text, not button
          khEls.input.value = '';
          return;
        }
        if (khState.pendingFunctionAction) {
          executeFunctionAction(false); // false = triggered by text, not button
          khEls.input.value = '';
          return;
        }
        if (khState.pendingPortfolioAction) {
          executePortfolioAction(false); // false = triggered by text, not button
          khEls.input.value = '';
          return;
        }
        
        // If user confirms but no pending action, check if they want filtering advice
        // (common after a column change when AI offers "let me know if you'd like filtering advice")
        if (khState.lastModifiedMetric) {
          addKHMessage('user', query);
          khEls.input.value = '';
          provideFilteringAdvice(khState.lastModifiedMetric);
          return;
        }
      }

      // Check if user is asking to add previously listed RIDs to Smart Select
      if (isAddToSmartSelectRequest(query) && khState.lastListedRIDs && khState.lastListedRIDs.length > 0) {
        console.log(`[sendKHMessage] User asking to add ${khState.lastListedRIDs.length} previously listed RIDs to Smart Select`);
        khState.pendingSmartSelectAction = { rids: khState.lastListedRIDs };
        addKHMessage('user', query);
        khEls.input.value = '';
        executeSmartSelectAction();
        return;
      }
      
      // Check if this is a Free Google RID (only if we have Free Google data loaded)
      if (khState.freeGoogleData && checkFreeGoogleRID(query)) {
        console.log('[sendKHMessage] Free Google RID detected, showing strategy options');
        khEls.input.value = '';
        return;
      }
      
      // Clear any pending actions if user asks something else
      khState.pendingColumnAction = null;
      khState.pendingFunctionAction = null;
      khState.pendingSlackAction = null;
      
      // Detect auto-isolate mode: query starts with "isolate" or "filter" (with optional pleasantries)
      const lowerQuery = query.toLowerCase();
      // Match: "isolate...", "filter...", "please isolate...", "kindly filter...", "can you isolate...", etc.
      const isolatePattern = /^(please\s+|kindly\s+|can\s+you\s+|could\s+you\s+|would\s+you\s+|i\s+want\s+to\s+|i\s+need\s+to\s+|let'?s\s+|just\s+)?(isolate|filter)\b/i;
      khState.autoIsolateMode = isolatePattern.test(lowerQuery);
      if (khState.autoIsolateMode) {
        console.log('[sendKHMessage] Auto-isolate mode activated (query starts with isolate/filter)');
      }

      // Add user message to UI
      addKHMessage('user', query);
      khEls.input.value = '';

      // Show loading - swap send/stop buttons
      khState.isLoading = true;
      khState.currentRequestId = Date.now(); // Track request for abort
      if (khEls.sendBtn) khEls.sendBtn.style.display = 'none';
      if (khEls.stopBtn) khEls.stopBtn.style.display = 'inline-flex';
      const loadingEl = addKHMessage('loading', '');

      // Build conversation history for context
      const historyJson = khState.conversationHistory.length > 0 
        ? JSON.stringify(khState.conversationHistory) 
        : null;

      // Check if we have valid cached AM data (not expired)
      const cachedData = (khState.cachedAMData && Date.now() < khState.cachedAMDataExpiry) 
        ? khState.cachedAMData 
        : null;
      if (cachedData) {
        console.log('[sendKHMessage] Using pre-fetched data for:', cachedData.amName);
      }

      // #region agent log
      console.log('[DEBUG-D] Calling google.script.run.askInTouchGuide', {
        queryLength: query.length,
        hasHistory: !!historyJson,
        hasCachedData: !!cachedData,
        shouldLog: khState.shouldLogNextChat
      });
      // #endregion
      // Call backend
      google.script.run
        .withSuccessHandler((result) => {
          // #region agent log
          console.log('[DEBUG-E] askInTouchGuide SUCCESS handler fired', {
            success: result ? result.success : '(null result)',
            hasError: result ? !!result.error : false,
            errorMsg: result ? result.error : '',
            isLoading: khState.isLoading,
            currentRequestId: khState.currentRequestId
          });
          // #endregion
          // Check if request was stopped
          if (!khState.isLoading && !khState.currentRequestId) {
            if (loadingEl) loadingEl.remove();
            return; // Request was stopped, ignore response
          }
          
          if (loadingEl) loadingEl.remove();
          khState.isLoading = false;
          khState.currentRequestId = null;
          // Reset buttons
          if (khEls.stopBtn) khEls.stopBtn.style.display = 'none';
          if (khEls.sendBtn) {
            khEls.sendBtn.style.display = 'inline-flex';
            khEls.sendBtn.disabled = false;
          }

          if (result.success) {
            // Debug: Log data injection status
            console.log('[sendKHMessage] Result data injection:', {
              dataInjected: result.dataInjected,
              dataSource: result.dataSource,
              hasAmContext: !!result.amContext,
              amContextName: (result.amContext && result.amContext.fullName) || 'none'
            });
            
            // Reset log flag after successful chat (first message was logged)
            khState.shouldLogNextChat = false;
            
            // Check if user needs to navigate to AM tab first
            if (result.notOnAMTab) {
              khState.pendingRetryQuery = result.originalQuery || query;
              khState.availableTabs = result.availableTabs || [];
              khState.suggestedTab = result.suggestedTab || null;
              
              addKHMessage('assistant', result.answer, true);  // showActionButtons=true to trigger retry button
              return;
            }
            
            // Check for action tags and extract them
            const { cleanedAnswer, columnAction, functionAction, slackAction, smartSelectAction, teamAnalysisAction, bucketSummaryAction, searchAction } = parseColumnAction(result.answer);
            
            if (columnAction) {
              khState.pendingColumnAction = columnAction;
            }
            if (functionAction) {
              khState.pendingFunctionAction = functionAction;
            }
            if (slackAction) {
              khState.pendingSlackAction = slackAction;
            }
            if (smartSelectAction) {
              khState.pendingSmartSelectAction = smartSelectAction;
              // Store AM context for tab verification
              if (result.amContext && result.amContext.fullName) {
                khState.currentAMContext = result.amContext;
              }
            }
            if (teamAnalysisAction) {
              khState.pendingTeamAnalysisAction = true;
            }

            if (bucketSummaryAction) {
              // Trigger portfolio analysis
              console.log('[sendKHMessage] Triggering Bucket Summary Action');
              setTimeout(() => {
                if (khState.currentAMContext && khState.currentAMContext.fullName) {
                  selectAMForAnalysis(khState.currentAMContext.fullName);
                } else {
                  // Fallback if AM context is missing
                  addKHMessage('assistant', "I need to know which Account Manager to analyze. Please select one:", true);
                  google.script.run
                    .withSuccessHandler(renderAMSelectionList)
                    .getAvailableAMTabs();
                }
              }, 500);
            }

            if (searchAction) {
              const loadingEl = addKHMessage('loading', '');
              google.script.run
                .withSuccessHandler(result => {
                  if (loadingEl) loadingEl.remove();
                  if (result.success && result.matches.length > 0) {
                    const list = result.matches.map(a => `- **${a.name}** (RID: ${a.rid}) - ${a.metro}`).join('\n');
                    addKHMessage('assistant', `I found these accounts in the database:\n\n${list}\n\nWhich one would you like to analyze?`);
                  } else {
                    addKHMessage('assistant', `I searched the entire database but couldn't find "${searchAction.query}". Please check the spelling or RID.`);
                  }
                })
                .withFailureHandler(error => {
                  if (loadingEl) loadingEl.remove();
                  addKHMessage('error', 'Search failed: ' + error.message);
                })
                .searchGlobalAccount(searchAction.query);
            }
            
            // Store AM context if data was injected
            if (result.amContext) {
              khState.currentAMContext = result.amContext;
            }
            
            // Add data source indicator if data was injected
            const dataIndicator = result.dataInjected && result.dataSource 
              ? `<div class="kh-data-indicator">üìä ${result.dataSource.amName} (${result.dataSource.totalAccounts} accounts)<\/div>`
              : '';
            
            // Debug: Log dataIndicator construction
            if (dataIndicator) {
              console.log('[sendKHMessage] ‚úì Data indicator WILL display:', dataIndicator);
            } else {
              console.log('[sendKHMessage] ‚úó Data indicator NOT displaying because:', {
                dataInjected: result.dataInjected,
                hasDataSource: !!result.dataSource,
                reason: !result.dataInjected ? 'dataInjected is false/undefined' : 'dataSource is null/undefined'
              });
            }
            
            // Extract and store any RIDs listed in the response for "add them" follow-ups
            const extractedRIDs = extractRIDsFromMessage(cleanedAnswer);
            if (extractedRIDs && extractedRIDs.length > 0) {
              console.log(`[sendKHMessage] Storing ${extractedRIDs.length} RIDs from response for potential Smart Select`);
              khState.lastListedRIDs = extractedRIDs;
            }
            
            // Check if we should auto-isolate: >10 RIDs OR autoIsolateMode active
            const shouldAutoIsolate = smartSelectAction && 
              (smartSelectAction.rids.length > 10 || khState.autoIsolateMode);
            
            if (shouldAutoIsolate) {
              console.log(`[sendKHMessage] Auto-isolate triggered: ${smartSelectAction.rids.length} RIDs, autoIsolateMode=${khState.autoIsolateMode}`);
              // Show the message without action buttons (we'll auto-execute and add new buttons after)
              addKHMessage('assistant', cleanedAnswer, false, dataIndicator);
              // Auto-execute check+filter
              executeAutoIsolate(smartSelectAction.rids, dataIndicator);
              // Reset autoIsolateMode
              khState.autoIsolateMode = false;
            } else {
              // Normal flow: show action buttons if there's a pending action
              const hasAction = !!columnAction || !!functionAction || !!slackAction || !!smartSelectAction || !!teamAnalysisAction;
              addKHMessage('assistant', cleanedAnswer, hasAction, dataIndicator);
            }
            
            // Add to history for follow-up context
            khState.conversationHistory.push({ role: 'user', content: query });
            khState.conversationHistory.push({ role: 'assistant', content: cleanedAnswer });
            // Keep history manageable (last 10 exchanges)
            if (khState.conversationHistory.length > 20) {
              khState.conversationHistory = khState.conversationHistory.slice(-20);
            }
          } else {
            addKHMessage('error', 'Error: ' + (result.error || 'Something went wrong'));
          }
        })
        .withFailureHandler((error) => {
          // #region agent log
          console.log('[DEBUG-F] askInTouchGuide FAILURE handler fired', {
            errorMessage: error ? error.message : '(null error)',
            errorFull: error ? JSON.stringify(error) : '(null)'
          });
          // #endregion
          if (loadingEl) loadingEl.remove();
          khState.isLoading = false;
          khState.currentRequestId = null;
          // Reset buttons
          if (khEls.stopBtn) khEls.stopBtn.style.display = 'none';
          if (khEls.sendBtn) {
            khEls.sendBtn.style.display = 'inline-flex';
            khEls.sendBtn.disabled = false;
          }
          addKHMessage('error', 'Error: ' + error.message);
        })
        .askInTouchGuide(query, historyJson, khState.shouldLogNextChat, cachedData);
    }
    
    /**
     * Stop the current AI request
     * Sets flags to ignore the response and resets UI
     */
    function stopKHRequest() {
      console.log('[stopKHRequest] Stopping current request');
      
      // Set flags to ignore any pending response
      khState.isLoading = false;
      khState.currentRequestId = null;
      
      // Remove any loading indicators
      const loadingEls = document.querySelectorAll('.kh-message.loading');
      loadingEls.forEach(el => el.remove());
      
      // Swap buttons back
      if (khEls.stopBtn) khEls.stopBtn.style.display = 'none';
      if (khEls.sendBtn) {
        khEls.sendBtn.style.display = 'inline-flex';
        khEls.sendBtn.disabled = false;
      }
      
      // Add system message
      addKHMessage('assistant', '_Request stopped. Ask me something else!_');
      
      // Focus input
      if (khEls.input) khEls.input.focus();
    }
    
    /**
     * Check if the query is a confirmation phrase
     */
    function isConfirmationPhrase(query) {
      // Check exact match or starts with confirmation
      return CONFIRMATION_PHRASES.some(phrase => 
        query === phrase || 
        query.startsWith(phrase + ' ') || 
        query.startsWith(phrase + '!')
      );
    }
    
    /**
     * Extract RIDs from a message that lists accounts
     * Looks for patterns like "‚Ä¢ 1234567 - Restaurant Name" or "**1234567** - Name"
     * @param {string} content - The message content
     * @returns {Array|null} Array of RID strings, or null if none found
     */
    function extractRIDsFromMessage(content) {
      if (!content) return null;
      
      const rids = [];
      
      // Pattern 1: Bullet list format "‚Ä¢ 1234567 - Restaurant Name"
      const bulletPattern = /[‚Ä¢\-\*]\s*(\d{4,10})\s*[\-‚Äì]/g;
      let match;
      while ((match = bulletPattern.exec(content)) !== null) {
        if (!rids.includes(match[1])) {
          rids.push(match[1]);
        }
      }
      
      // Pattern 2: Bold RID format "**1234567** - Name"
      const boldPattern = /\*\*(\d{4,10})\*\*/g;
      while ((match = boldPattern.exec(content)) !== null) {
        if (!rids.includes(match[1])) {
          rids.push(match[1]);
        }
      }
      
      // Pattern 3: RID at start of line "1234567 - Restaurant"
      const linePattern = /^(\d{4,10})\s*[\-‚Äì]/gm;
      while ((match = linePattern.exec(content)) !== null) {
        if (!rids.includes(match[1])) {
          rids.push(match[1]);
        }
      }
      
      if (rids.length > 0) {
        console.log(`[extractRIDsFromMessage] Found ${rids.length} RIDs in message`);
        return rids;
      }
      
      return null;
    }
    
    /**
     * Check if query is asking to add previously listed items to Smart Select
     * @param {string} query - The user's query
     * @returns {boolean} True if this is an "add them" type request
     */
    function isAddToSmartSelectRequest(query) {
      if (!query) return false;
      const patterns = [
        /add\s*(them|those|these|the\s*rids?|all)?\s*to\s*(my\s*)?(smart\s*)?select/i,
        /check\s*(them|those|these|all)\s*(in|on)\s*(smart\s*)?select/i,
        /put\s*(them|those|these)\s*(in|on)\s*(smart\s*)?select/i,
        /select\s*(them|those|these|all)/i,
        /yes,?\s*(add|check)\s*(them)?/i,
        /^(yes|yeah|yep|sure|ok|please|do it)\s*$/i  // Simple confirmation after RID list
      ];
      return patterns.some(p => p.test(query.trim()));
    }
    
    /**
     * Parse action tags from AI response
     * Supports [COLUMN_ACTION:...], [FUNCTION_ACTION:...], [SLACK_ACTION:...], [SMART_SELECT_ACTION:...], [TEAM_ANALYSIS_ACTION]
     * Returns { cleanedAnswer, columnAction, functionAction, slackAction, smartSelectAction, teamAnalysisAction }
     */
    function parseColumnAction(answer) {
      let columnAction = null;
      let functionAction = null;
      let smartSelectAction = null;
      let teamAnalysisAction = false;
      let bucketSummaryAction = false;
      let searchAction = null;
      
      // Match category-based column format: [COLUMN_ACTION:CATEGORY_KEY:Metric Name]
      const columnRegex = /\[COLUMN_ACTION:([A-Z_]+):([^\]]+)\]/g;
      const columnMatch = columnRegex.exec(answer);
      if (columnMatch) {
        const categoryKey = columnMatch[1];
        const metric = columnMatch[2].trim();
        
        // Validate the category exists
        if (COLUMN_CATEGORIES[categoryKey]) {
          columnAction = {
            category: categoryKey,
            metric: metric
          };
        } else {
          // Fallback: if it looks like a column letter (legacy format), try to map it
          const legacyColumnMap = {
            'E': 'ACCOUNT_IDS', 'G': 'ACCOUNT_NAME', 'I': 'LOCATION',
            'J': 'DATES_ACTIVITY', 'K': 'DATES_ACTIVITY', 'L': 'DATES_ACTIVITY',
            'M': 'ACCOUNT_STATUS', 'N': 'ACCOUNT_STATUS', 'O': 'ACCOUNT_STATUS',
            'P': 'SYSTEM_STATS', 'Q': 'SYSTEM_STATS', 'R': 'SYSTEM_STATS',
            'S': 'PERCENTAGE_METRICS', 'T': 'PERCENTAGE_METRICS', 'U': 'PERCENTAGE_METRICS',
            'V': 'REVENUE', 'W': 'REVENUE', 'X': 'REVENUE',
            'Y': 'SEATED_COVERS', 'Z': 'SEATED_COVERS', 'AA': 'SEATED_COVERS',
            'AB': 'PRICING', 'AC': 'PRICING', 'AD': 'PRICING'
          };
          
          if (legacyColumnMap[categoryKey]) {
            console.log('[parseColumnAction] Converting legacy column format:', categoryKey);
            columnAction = {
              category: legacyColumnMap[categoryKey],
              metric: metric
            };
          } else {
            console.warn('[parseColumnAction] Unknown category/column:', categoryKey);
          }
        }
      }
      
      // Match function action format: [FUNCTION_ACTION:functionName:Button Label]
      const functionRegex = /\[FUNCTION_ACTION:([a-zA-Z_]+):([^\]]+)\]/g;
      const functionMatch = functionRegex.exec(answer);
      if (functionMatch) {
        functionAction = {
          functionName: functionMatch[1],
          label: functionMatch[2].trim()
        };
        console.log('[parseColumnAction] Found function action:', functionAction);
      }
      
      // Match Slack action format: [SLACK_ACTION:channel-name]
      let slackAction = null;
      const slackRegex = /\[SLACK_ACTION:([^\]]+)\]/g;
      const slackMatch = slackRegex.exec(answer);
      if (slackMatch) {
        slackAction = {
          channel: slackMatch[1].trim()
        };
        console.log('[parseColumnAction] Found Slack action:', slackAction);
      }
      
      // Match Smart Select action format: [SMART_SELECT_ACTION:rid1,rid2,rid3,...]
      const smartSelectRegex = /\[SMART_SELECT_ACTION:([^\]]+)\]/g;
      const smartSelectMatch = smartSelectRegex.exec(answer);
      if (smartSelectMatch) {
        const ridsString = smartSelectMatch[1].trim();
        const rids = ridsString.split(',').map(r => r.trim()).filter(r => r);
        if (rids.length > 0) {
          smartSelectAction = { rids: rids };
          console.log('[parseColumnAction] Found Smart Select action:', smartSelectAction);
        }
      }
      
      // Match Team Analysis action: [TEAM_ANALYSIS_ACTION]
      const teamAnalysisRegex = /\[TEAM_ANALYSIS_ACTION\]/g;
      if (teamAnalysisRegex.test(answer)) {
        teamAnalysisAction = true;
        console.log('[parseColumnAction] Found Team Analysis action');
      }

      // Match Bucket Summary action: [BUCKET_SUMMARY_ACTION]
      const bucketSummaryRegex = /\[BUCKET_SUMMARY_ACTION\]/g;
      if (bucketSummaryRegex.test(answer)) {
        bucketSummaryAction = true;
        console.log('[parseColumnAction] Found Bucket Summary action');
      }
      
      // Match Search action: [SEARCH_ACTION:Query]
      const searchRegex = /\[SEARCH_ACTION:([^\]]+)\]/g;
      const searchMatch = searchRegex.exec(answer);
      if (searchMatch) {
        searchAction = { query: searchMatch[1].trim() };
        console.log('[parseColumnAction] Found Search action:', searchAction);
      }

      // Remove all action tags from the displayed answer
      const cleanedAnswer = answer
        .replace(/\[COLUMN_ACTION:[^\]]+\]/g, '')
        .replace(/\[FUNCTION_ACTION:[^\]]+\]/g, '')
        .replace(/\[SLACK_ACTION:[^\]]+\]/g, '')
        .replace(/\[SMART_SELECT_ACTION:[^\]]+\]/g, '')
        .replace(/\[TEAM_ANALYSIS_ACTION\]/g, '')
        .replace(/\[BUCKET_SUMMARY_ACTION\]/g, '')
        .replace(/\[SEARCH_ACTION:[^\]]+\]/g, '')
        .replace(/\[PORTFOLIO_ACTION:[^\]]*\]/g, '')  // Keep for backward compatibility
        .trim();
      
      return { cleanedAnswer, columnAction, functionAction, slackAction, smartSelectAction, teamAnalysisAction, bucketSummaryAction, searchAction };
    }
    
    /**
     * Resolve which column to use for a given category
     * Implements column rotation: uses next available column in the section
     * If section is exhausted, wraps back to first column
     * @param {string} categoryKey - The category key (e.g., 'DATES_ACTIVITY')
     * @returns {string} The column letter to use (e.g., 'J', 'K', or 'L')
     */
    function resolveColumnForCategory(categoryKey) {
      const category = COLUMN_CATEGORIES[categoryKey];
      if (!category) {
        console.error('[resolveColumnForCategory] Unknown category:', categoryKey);
        return null;
      }
      
      const columns = category.columns;
      
      // Find the first column in this category that hasn't been modified this session
      for (const col of columns) {
        if (!khState.modifiedColumns[col]) {
          console.log(`[resolveColumnForCategory] ${categoryKey} ‚Üí using unmodified column ${col}`);
          return col;
        }
      }
      
      // All columns in section are modified, wrap back to first
      console.log(`[resolveColumnForCategory] ${categoryKey} ‚Üí section exhausted, wrapping to ${columns[0]}`);
      return columns[0];
    }
    
    /**
     * Execute the pending column action
     * Now uses category-based resolution with column rotation
     * @param {boolean} fromButton - If true, called from action button (don't add "Yes" message)
     */
    function executeColumnAction(fromButton = true) {
      if (!khState.pendingColumnAction) return;
      
      const { category, metric } = khState.pendingColumnAction;
      
      // Resolve which column to use (handles rotation)
      const resolvedColumn = resolveColumnForCategory(category);
      if (!resolvedColumn) {
        addKHMessage('error', 'Could not determine which column to use.');
        khState.pendingColumnAction = null;
        return;
      }
      
      // Remove action buttons if they exist
      const actionButtons = document.querySelector('.kh-action-buttons');
      if (actionButtons) {
        actionButtons.remove();
      }
      
      // Add user confirmation message only if triggered by text (not button)
      if (!fromButton) {
        addKHMessage('user', 'Yes');
      }
      
      // Show loading
      khState.isLoading = true;
      if (khEls.sendBtn) khEls.sendBtn.disabled = true;
      const loadingEl = addKHMessage('loading', '');
      
      console.log(`[executeColumnAction] Setting column ${resolvedColumn} to "${metric}" (category: ${category})`);
      
      // Call backend to set the column
      google.script.run
        .withSuccessHandler((result) => {
          if (loadingEl) loadingEl.remove();
          khState.isLoading = false;
          if (khEls.sendBtn) khEls.sendBtn.disabled = false;
          
          if (result.success) {
            // Track this modification for column rotation and filtering advice context
            khState.modifiedColumns[result.column] = result.metric;
            khState.lastModifiedMetric = result.metric;
            console.log('[executeColumnAction] Tracked modification:', khState.modifiedColumns);
            
            // Get the section name for a friendly message
            const sectionName = (COLUMN_CATEGORIES[category] && COLUMN_CATEGORIES[category].name) || category;
            
            // Check if column was already set to this metric
            if (result.alreadySet) {
              addKHMessage('assistant', `**${result.metric}** is already showing in **Column ${result.column}**! You're all set.\n\nWould you like advice on how to filter this column for the best analysis view?`);
            } else {
              addKHMessage('assistant', `Done! I've set **Column ${result.column}** to **${result.metric}** in the ${sectionName} section.\n\nLet me know if you'd like advice on how to filter this column for the best analysis view!`);
            }
            
            // Clear the pending action
            khState.pendingColumnAction = null;
          } else {
            addKHMessage('error', 'Could not set column: ' + (result.error || 'Unknown error'));
            khState.pendingColumnAction = null;
          }
        })
        .withFailureHandler((error) => {
          if (loadingEl) loadingEl.remove();
          khState.isLoading = false;
          if (khEls.sendBtn) khEls.sendBtn.disabled = false;
          addKHMessage('error', 'Error: ' + error.message);
          khState.pendingColumnAction = null;
        })
        .setDynamicColumnHeader(resolvedColumn, metric);
    }

    // Track last query for feedback
    let khLastQuery = '';

    function addKHMessage(type, content, showActionButtons = false, dataIndicator = '') {
      if (!khEls.messages) return null;
      const msgEl = document.createElement('div');
      msgEl.className = 'kh-message ' + type;

      if (type === 'loading') {
        msgEl.innerHTML = '<div class="kh-loading-dots"><span><\/span><span><\/span><span><\/span><\/div>';
      } else if (type === 'assistant') {
        // Generate unique ID for this message
        const msgId = 'kh-msg-' + Date.now();
        msgEl.id = msgId;
        msgEl.dataset.response = content;
        msgEl.dataset.query = khLastQuery;
        
        // Data indicator shows which AM's data was loaded
        const indicatorHtml = dataIndicator || '';
        
        // Debug: Log indicator in addKHMessage
        console.log('[addKHMessage] Indicator received:', {
          hasIndicator: !!dataIndicator,
          indicatorLength: (dataIndicator && dataIndicator.length) || 0,
          indicatorHtml: indicatorHtml || '(empty)'
        });
        
        let actionButtonsHtml = '';
        if (showActionButtons) {
          if (khState.pendingColumnAction) {
            actionButtonsHtml = `
              <div class="kh-action-buttons">
                <button class="kh-action-btn primary" onclick="executeColumnAction()">
                  <span>‚ñ∂<\/span> Add Column
                <\/button>
                <button class="kh-action-btn secondary" onclick="dismissAction()">
                  Not now
                <\/button>
              <\/div>
            `;
          } else if (khState.pendingFunctionAction) {
            const label = khState.pendingFunctionAction.label || 'Run';
            // Check if we should show Reset button (after auto-isolate)
            if (khState.showResetButton) {
              actionButtonsHtml = `
                <div class="kh-action-buttons">
                  <button class="kh-action-btn primary" onclick="executeFunctionAction()">
                    <span>‚ñ∂<\/span> ${label}
                  <\/button>
                  <button class="kh-action-btn secondary" onclick="executeReset()">
                    <span>‚Ü∫<\/span> Reset Filters
                  <\/button>
                <\/div>
              `;
            } else {
              actionButtonsHtml = `
                <div class="kh-action-buttons">
                  <button class="kh-action-btn primary" onclick="executeFunctionAction()">
                    <span>‚ñ∂<\/span> ${label}
                  <\/button>
                  <button class="kh-action-btn secondary" onclick="dismissAction()">
                    Not now
                  <\/button>
                <\/div>
              `;
            }
          } else if (khState.pendingSlackAction) {
            const channel = khState.pendingSlackAction.channel;
            actionButtonsHtml = `
              <div class="kh-action-buttons">
                <button class="kh-action-btn slack" onclick="openSlackChannel('${channel}')">
                  Open #${channel} in Slack
                <\/button>
                <button class="kh-action-btn secondary" onclick="dismissAction()">
                  Not now
                <\/button>
              <\/div>
            `;
          } else if (khState.pendingSmartSelectAction) {
            const count = khState.pendingSmartSelectAction.rids.length;
            actionButtonsHtml = `
              <div class="kh-action-buttons">
                <button class="kh-action-btn primary" onclick="executeSmartSelectAction()">
                  <span>‚úì<\/span> Check ${count} in Smart Select
                <\/button>
                <button class="kh-action-btn secondary" onclick="dismissAction()">
                  Not now
                <\/button>
              <\/div>
            `;
          } else if (khState.pendingTeamAnalysisAction) {
            actionButtonsHtml = `
              <div class="kh-action-buttons">
                <button class="kh-action-btn primary" onclick="executeTeamAnalysis()">
                  <span>üë•<\/span> Run Team Analysis
                <\/button>
                <button class="kh-action-btn secondary" onclick="dismissAction()">
                  Not now
                <\/button>
              <\/div>
            `;
          } else if (khState.pendingRetryQuery) {
            let switchControls = '';
            
            // If we have a suggested tab (direct match), show a button
            if (khState.suggestedTab) {
                switchControls = `
                  <div class="kh-tab-switcher" style="margin-bottom: 8px;">
                    <button class="kh-action-btn primary" onclick="switchAndRetry('${khState.suggestedTab.replace(/'/g, "\\'")}')" style="width: 100%;">
                      Switch to ${khState.suggestedTab} & Retry
                    <\/button>
                  <\/div>
                `;
            } 
            // If we have available tabs, show a dropdown
            else if (khState.availableTabs && khState.availableTabs.length > 0) {
                const options = khState.availableTabs.map(am => `<option value="${am.tabName}">${am.fullName}<\/option>`).join('');
                switchControls = `
                    <div class="kh-tab-switcher" style="display: flex; gap: 4px; margin-bottom: 8px;">
                        <select id="kh-am-select" class="kh-select" style="flex: 1; padding: 4px; border-radius: 4px; border: 1px solid #cbd5e1;">
                            <option value="">Select your AM tab...<\/option>
                            ${options}
                        <\/select>
                        <button class="kh-action-btn primary" onclick="switchAndRetryFromSelect()" style="flex: none;">
                            Go
                        <\/button>
                    <\/div>
                `;
            }

            actionButtonsHtml = `
              <div class="kh-action-buttons column-layout">
                ${switchControls}
                <button class="kh-action-btn secondary" onclick="executeRetryQuery()">
                  I'm already there, try again
                <\/button>
              <\/div>
            `;
          }
        }
        
        msgEl.innerHTML = indicatorHtml + formatKHResponse(content) + actionButtonsHtml + `
          <div class="kh-feedback">
            <span class="kh-feedback-label">Rate<\/span>
            <button class="kh-feedback-btn" onclick="submitKHFeedback('${msgId}', 'helpful')" title="Helpful">üëç<\/button>
            <button class="kh-feedback-btn" onclick="submitKHFeedback('${msgId}', 'not_helpful')" title="Not helpful">üëé<\/button>
            <button class="kh-feedback-btn" onclick="openKHCorrection('${msgId}')" title="Suggest correction">‚úèÔ∏è<\/button>
            <span class="kh-feedback-text"><\/span>
          <\/div>
        `;
      } else if (type === 'user') {
        khLastQuery = content; // Store for feedback
        msgEl.textContent = content;
      } else {
        msgEl.textContent = content;
      }

      khEls.messages.appendChild(msgEl);
      khEls.messages.scrollTop = khEls.messages.scrollHeight;
      return msgEl;
    }
    
    /**
     * Provide contextual filtering advice based on the last modified metric
     * Called when user confirms after a column change
     * @param {string} metric - The metric name that was just added
     */
    function provideFilteringAdvice(metric) {
      const metricLower = metric.toLowerCase();
      let advice = '';
      
      // Contextual filtering advice based on metric type
      if (metricLower.includes('metro') || metricLower.includes('neighborhood') || metricLower.includes('macro')) {
        advice = `**Filtering ${metric}:**\n\n1. Click the **${metric}** column header dropdown\n2. Select **Filter by values**\n3. Uncheck "Select all", then check the specific locations you want\n4. Click OK\n\n**Pro tip:** After filtering to your target area, use Smart Select to mark priority accounts for Focus20!`;
      } else if (metricLower.includes('status') || metricLower.includes('system type')) {
        advice = `**Filtering ${metric}:**\n\n1. Click the **${metric}** column header dropdown\n2. Select **Filter by values**\n3. Uncheck "Select all", then check the values you want (e.g., "Core", "Active")\n4. Click OK\n\n**Common filters:**\n- Filter for "Term Pending" to see accounts needing renewal conversations\n- Filter for specific system types to segment your outreach`;
      } else if (metricLower.includes('disco') || metricLower.includes('%') || metricLower.includes('percent')) {
        advice = `**Filtering ${metric}:**\n\n**To find low-performing accounts:**\n1. Click the column header ‚Üí Sort A‚ÜíZ (low to high)\n2. Focus on the bottom performers\n\n**To find top performers:**\n1. Sort Z‚ÜíA (high to low)\n\n**For threshold filtering:**\n1. Click dropdown ‚Üí Filter by condition\n2. Use "Greater than" or "Less than" with your target value`;
      } else if (metricLower.includes('revenue') || metricLower.includes('yield') || metricLower.includes('due')) {
        advice = `**Filtering ${metric}:**\n\n**To find top revenue accounts:**\n1. Sort Z‚ÜíA (high to low) - top performers appear first\n\n**To find underperformers:**\n1. Sort A‚ÜíZ (low to high)\n\n**For specific thresholds:**\n1. Filter by condition ‚Üí "Greater than" or "Less than"\n2. Enter your dollar threshold`;
      } else if (metricLower.includes('cvr') || metricLower.includes('cover')) {
        advice = `**Filtering ${metric}:**\n\n**To analyze cover volume:**\n1. Sort Z‚ÜíA for highest volume accounts\n2. Sort A‚ÜíZ to find accounts with low/no bookings\n\n**Compare channels:** Set multiple cover columns (Y, Z, AA) to different channels to see the distribution side-by-side.`;
      } else if (metricLower.includes('date') || metricLower.includes('term') || metricLower.includes('since') || metricLower.includes('engaged')) {
        advice = `**Filtering ${metric}:**\n\n**For date-based columns:**\n1. Sort oldest-first (A‚ÜíZ) to see upcoming deadlines or longest tenures\n2. Sort newest-first (Z‚ÜíA) for recent activity\n\n**For specific date ranges:**\n1. Filter by condition ‚Üí "Date is before" or "Date is after"\n2. Enter your target date\n\n**Pro tip:** For contract alerts, sort to surface expired/pending terms first!`;
      } else if (metricLower.includes('focus20')) {
        advice = `**Using the Focus20 column:**\n\nThis column shows the date each account was added to your Focus20 list.\n\n**To see your current Focus20:**\n1. Filter by condition ‚Üí "Is not empty"\n2. This shows only accounts in your Focus20\n\n**To refresh your list:**\n1. Sort by date added (oldest first)\n2. Consider rotating out accounts that have been there 2+ weeks\n3. Use Smart Select + X to remove, then add fresh priorities with +`;
      } else {
        // Generic advice
        advice = `**Filtering ${metric}:**\n\n1. Click the column header dropdown\n2. Choose **Sort A‚ÜíZ** or **Sort Z‚ÜíA** for quick ordering\n3. Use **Filter by values** to select specific items\n4. Use **Filter by condition** for numeric thresholds\n\n**Remember:** Click RESET to clear all filters when done!`;
      }
      
      // Clear the lastModifiedMetric so we don't keep offering advice
      khState.lastModifiedMetric = null;
      
      addKHMessage('assistant', advice);
    }

    /**
     * Dismiss any pending action without executing
     */
    function dismissAction() {
      khState.pendingColumnAction = null;
      khState.pendingFunctionAction = null;
      khState.pendingSlackAction = null;
      khState.pendingSmartSelectAction = null;
      khState.pendingTeamAnalysisAction = false;
      khState.autoIsolateMode = false;
      khState.showResetButton = false;
      // Remove the action buttons from the last message
      const actionButtons = document.querySelector('.kh-action-buttons');
      if (actionButtons) {
        actionButtons.remove();
      }
    }
    
    /**
     * Open a Slack channel in a new window
     * @param {string} channel - The channel name (without #)
     */
    function openSlackChannel(channel) {
      // Remove action buttons
      const actionButtons = document.querySelector('.kh-action-buttons');
      if (actionButtons) {
        actionButtons.remove();
      }
      
      // Open Slack channel (web URL format)
      const slackUrl = 'https:\/\/slack.com\/app_redirect?channel=' + encodeURIComponent(channel);
      window.open(slackUrl, '_blank');
      
      // Clear the pending action
      khState.pendingSlackAction = null;
      
      // Add confirmation message
      addKHMessage('assistant', 'Opening #' + channel + ' in Slack. The support team is happy to help!');
    }
    
    /**
     * Execute a pending function action (like manualUpdateNotesOnly)
     * @param {boolean} fromButton - If true, called from action button (don't add "Yes" message)
     */
    function executeFunctionAction(fromButton = true) {
      if (!khState.pendingFunctionAction) return;
      
      const { functionName, label } = khState.pendingFunctionAction;
      
      // Remove action buttons if they exist
      const actionButtons = document.querySelector('.kh-action-buttons');
      if (actionButtons) {
        actionButtons.remove();
      }
      
      // Add user confirmation message only if triggered by text (not button)
      if (!fromButton) {
        addKHMessage('user', 'Yes');
      }
      
      // Show loading
      khState.isLoading = true;
      if (khEls.sendBtn) khEls.sendBtn.disabled = true;
      const loadingEl = addKHMessage('loading', '');
      
      console.log(`[executeFunctionAction] Running function: ${functionName}`);
      
      // Call the backend function dynamically
      google.script.run
        .withSuccessHandler((result) => {
          if (loadingEl) loadingEl.remove();
          khState.isLoading = false;
          if (khEls.sendBtn) khEls.sendBtn.disabled = false;
          
          addKHMessage('assistant', `Done! The **${label}** operation completed successfully. The notes across your sheet have been updated from Salesforce. Let me know if you need anything else!`);
          khState.pendingFunctionAction = null;
        })
        .withFailureHandler((error) => {
          if (loadingEl) loadingEl.remove();
          khState.isLoading = false;
          if (khEls.sendBtn) khEls.sendBtn.disabled = false;
          addKHMessage('error', 'Error running function: ' + error.message);
          khState.pendingFunctionAction = null;
        })
        [functionName](); // Dynamic function call
    }

    // =========================================================
    // --- SMART SELECT ACTION ---
    // =========================================================
    
    /**
     * Execute Smart Select action - check specified RIDs in Column D
     */
    function executeSmartSelectAction() {
      if (!khState.pendingSmartSelectAction || !khState.pendingSmartSelectAction.rids) {
        addKHMessage('error', 'No RIDs to check. Please ask me to list the accounts first, then I can add them to Smart Select.');
        return;
      }
      
      const rids = khState.pendingSmartSelectAction.rids;
      const amName = khState.currentAMContext ? khState.currentAMContext.fullName : '';
      
      // Remove action buttons
      const actionButtons = document.querySelector('.kh-action-buttons');
      if (actionButtons) {
        actionButtons.remove();
      }
      
      // Show loading
      khState.isLoading = true;
      if (khEls.sendBtn) khEls.sendBtn.disabled = true;
      const loadingEl = addKHMessage('loading', '');
      
      console.log(`[executeSmartSelectAction] Checking ${rids.length} RIDs for AM: "${amName}"`);
      console.log(`[executeSmartSelectAction] First few RIDs:`, rids.slice(0, 5));
      
      google.script.run
        .withSuccessHandler((result) => {
          if (loadingEl) loadingEl.remove();
          khState.isLoading = false;
          if (khEls.sendBtn) khEls.sendBtn.disabled = false;
          
          if (result.success) {
            let message = `Done! I've checked **${result.checkedCount}** account${result.checkedCount > 1 ? 's' : ''} in Smart Select (Column D).\n\n`;
            
            message += `**Next Steps:**\n`;
            message += `- Click **+** above Column E to add these to Focus20\n`;
            message += `- Click **X** to remove from Focus20\n\n`;
            
            message += `**To filter to just these accounts:**\n`;
            message += `1. Click the Smart Select column header (Column D)\n`;
            message += `2. Filter by condition ‚Üí "Is equal to" ‚Üí TRUE\n\n`;
            
            message += `**To clear Smart Select:** Click the **RESET** button above Column E.`;
            
            if (result.notFoundCount > 0) {
              message += `\n\n*Note: ${result.notFoundCount} RIDs were not found on this sheet (they may be filtered out or on a different tab).*`;
            }
            
            message += `\n\nIf you have any other questions about your account data I'd be happy to dive in with you!`;
            
            // Set up Focus20 action for the button
            khState.pendingFunctionAction = {
              functionName: 'moveTrueAccountsToFocus20',
              label: 'Add to Focus20'
            };
            
            addKHMessage('assistant', message, true);  // true = show action buttons
          } else if (result.wrongTab) {
            // User is on wrong tab - show warning
            addKHMessage('assistant', `**Heads up:** You are not currently on **${result.expectedTab}**'s tab. You're on **${result.currentTab || 'a different sheet'}**.

Please navigate to ${result.expectedTab}'s tab and try again, or ask about the accounts on your current tab.`);
          } else {
            // Provide more helpful error
            let errorMsg = result.error || 'Unknown error';
            if (result.hint) {
              errorMsg += `\n\n*${result.hint}*`;
            }
            addKHMessage('assistant', `Could not check RIDs: ${errorMsg}\n\nMake sure you're on the correct AM's tab and try again.`);
          }
          
          khState.pendingSmartSelectAction = null;
        })
        .withFailureHandler((error) => {
          if (loadingEl) loadingEl.remove();
          khState.isLoading = false;
          if (khEls.sendBtn) khEls.sendBtn.disabled = false;
          addKHMessage('error', 'Error: ' + error.message);
          khState.pendingSmartSelectAction = null;
        })
        .checkRIDsInSmartSelect(rids, amName);
    }
    
    /**
     * Execute auto-isolate flow: check RIDs in Smart Select AND apply filter
     * Triggered when: >10 RIDs in response OR query started with "isolate"/"filter"
     * Supports LAYERED filtering: if already isolated, finds intersection with new RIDs
     * @param {Array} rids - Array of RID strings
     * @param {string} dataIndicator - Optional data indicator HTML
     */
    function executeAutoIsolate(rids, dataIndicator = '') {
      if (!rids || rids.length === 0) {
        addKHMessage('error', 'No RIDs to isolate.');
        return;
      }
      
      const amName = khState.currentAMContext ? khState.currentAMContext.fullName : '';
      const isLayering = khState.isolatedRIDs && khState.isolatedRIDs.length > 0;
      
      // Show loading
      khState.isLoading = true;
      if (khEls.sendBtn) khEls.sendBtn.disabled = true;
      const loadingEl = addKHMessage('loading', '');
      
      if (isLayering) {
        console.log(`[executeAutoIsolate] LAYERING: ${rids.length} new RIDs onto ${khState.isolatedRIDs.length} existing`);
      } else {
        console.log(`[executeAutoIsolate] FRESH isolate: ${rids.length} RIDs for AM: "${amName}"`);
      }
      
      // Choose the appropriate server function
      const serverFunction = isLayering ? 'layerSmartSelectFilter' : 'checkAndFilterSmartSelect';
      const serverArgs = isLayering ? [rids, khState.isolatedRIDs, amName] : [rids, amName];
      
      const handleSuccess = (result) => {
        if (loadingEl) loadingEl.remove();
        khState.isLoading = false;
        if (khEls.sendBtn) khEls.sendBtn.disabled = false;
        
        if (result.success) {
          // Store the isolated RIDs for potential layering
          khState.isolatedRIDs = result.isolatedRIDs || rids.filter(r => !result.notFoundRIDs || !result.notFoundRIDs.includes(r));
          
          let message;
          if (isLayering) {
            message = `‚úÖ **Layered filter applied** - now showing **${result.checkedCount}** account${result.checkedCount !== 1 ? 's' : ''} that match both criteria.\n\n`;
            message += `If you tell me more about what you are researching, I can help with your analysis.`;
          } else {
            message = `‚úÖ **Isolated ${result.checkedCount}** account${result.checkedCount !== 1 ? 's' : ''} - your sheet is now filtered to show only these RIDs.\n\n`;
            message += `If you tell me more about what you are researching, I can help with your analysis.`;
          }
          
          if (result.notFoundCount > 0) {
            message += `*Note: ${result.notFoundCount} RIDs were not found on this sheet.*\n\n`;
          }
          
          // Set up Focus20 action for the button
          khState.pendingFunctionAction = {
            functionName: 'moveTrueAccountsToFocus20',
            label: 'Add to Focus20'
          };
          
          // Mark that we need to show Reset button too
          khState.showResetButton = true;
          
          addKHMessage('assistant', message, true, dataIndicator);
        } else if (result.wrongTab) {
          addKHMessage('assistant', `**Heads up:** You are not currently on **${result.expectedTab}**'s tab. You're on **${result.currentTab || 'a different sheet'}**.

Please navigate to ${result.expectedTab}'s tab and try again, or ask about the accounts on your current tab.`);
        } else if (result.noIntersection) {
          addKHMessage('assistant', `**No matching accounts found.** None of the requested RIDs overlap with your current filter.\n\nTry a different criteria, or click **Reset** to start fresh.`);
          khState.showResetButton = true;
          khState.pendingFunctionAction = null;
          addKHMessage('assistant', '', true); // Show reset button
        } else {
          let errorMsg = result.error || 'Unknown error';
          addKHMessage('assistant', `Could not isolate RIDs: ${errorMsg}\n\nMake sure you're on the correct AM's tab and try again.`);
        }
        
        khState.pendingSmartSelectAction = null;
      };
      
      const handleFailure = (error) => {
        if (loadingEl) loadingEl.remove();
        khState.isLoading = false;
        if (khEls.sendBtn) khEls.sendBtn.disabled = false;
        addKHMessage('error', 'Error: ' + error.message);
        khState.pendingSmartSelectAction = null;
      };
      
      // Call the appropriate server function
      if (isLayering) {
        google.script.run
          .withSuccessHandler(handleSuccess)
          .withFailureHandler(handleFailure)
          .layerSmartSelectFilter(rids, khState.isolatedRIDs, amName);
      } else {
        google.script.run
          .withSuccessHandler(handleSuccess)
          .withFailureHandler(handleFailure)
          .checkAndFilterSmartSelect(rids, amName);
      }
    }
    
    /**
     * Execute Reset action - clears Smart Select and removes filter
     * Called from the Reset button after auto-isolate
     */
    function executeReset() {
      // Remove action buttons
      const actionButtons = document.querySelector('.kh-action-buttons');
      if (actionButtons) {
        actionButtons.remove();
      }
      
      // Show loading
      khState.isLoading = true;
      if (khEls.sendBtn) khEls.sendBtn.disabled = true;
      const loadingEl = addKHMessage('loading', '');
      
      console.log('[executeReset] Resetting Smart Select and filters');
      
      google.script.run
        .withSuccessHandler((result) => {
          if (loadingEl) loadingEl.remove();
          khState.isLoading = false;
          if (khEls.sendBtn) khEls.sendBtn.disabled = false;
          
          if (result.success) {
            addKHMessage('assistant', `‚úÖ **Reset complete!** Smart Select has been cleared and all filters removed.\n\nWhat would you like to explore next?`);
          } else {
            addKHMessage('assistant', `Could not reset: ${result.error || 'Unknown error'}\n\nYou can manually reset by clicking the RESET button above Column E.`);
          }
          
          // Clear pending actions and isolated state
          khState.pendingFunctionAction = null;
          khState.showResetButton = false;
          khState.isolatedRIDs = null;  // Clear layered filter state
        })
        .withFailureHandler((error) => {
          if (loadingEl) loadingEl.remove();
          khState.isLoading = false;
          if (khEls.sendBtn) khEls.sendBtn.disabled = false;
          addKHMessage('error', 'Error: ' + error.message);
        })
        .resetInTouchView();
    }

    // =========================================================
    // --- PORTFOLIO/TEAM ANALYSIS FUNCTIONS ---
    // =========================================================
    
    /**
     * Execute portfolio analysis for the pending AM
     * @param {boolean} fromButton - If true, called from action button (don't add "Yes" message)
     */
    function executePortfolioAction(fromButton = true) {
      if (!khState.pendingPortfolioAction || khState.pendingPortfolioAction.type !== 'CONFIRM') return;
      
      const amName = khState.pendingPortfolioAction.amName;
      
      // Remove action buttons if they exist
      const actionButtons = document.querySelector('.kh-action-buttons');
      if (actionButtons) {
        actionButtons.remove();
      }
      
      // Add user confirmation message only if triggered by text (not button)
      if (!fromButton) {
        addKHMessage('user', 'Yes');
      }
      
      // Show loading
      khState.isLoading = true;
      if (khEls.sendBtn) khEls.sendBtn.disabled = true;
      const loadingEl = addKHMessage('loading', '');
      
      console.log(`[executePortfolioAction] Analyzing portfolio for: ${amName}`);
      
      // Call backend to get portfolio data
      google.script.run
        .withSuccessHandler((result) => {
          if (loadingEl) loadingEl.remove();
          khState.isLoading = false;
          if (khEls.sendBtn) khEls.sendBtn.disabled = false;
          
          if (result.success) {
            // Store the data for follow-up questions
            khState.lastPortfolioData = result.data;
            
            // Format and display the analysis
            const formattedAnalysis = formatPortfolioAnalysis(result.data);
            addKHMessage('assistant', formattedAnalysis);
            
            // Add to conversation history so Gemini has context
            khState.conversationHistory.push({ 
              role: 'assistant', 
              content: `[Portfolio data loaded for ${amName}]\n${JSON.stringify(result.data)}` 
            });
          } else {
            addKHMessage('error', 'Could not analyze portfolio: ' + (result.error || 'Unknown error'));
          }
          khState.pendingPortfolioAction = null;
        })
        .withFailureHandler((error) => {
          if (loadingEl) loadingEl.remove();
          khState.isLoading = false;
          if (khEls.sendBtn) khEls.sendBtn.disabled = false;
          addKHMessage('error', 'Error: ' + error.message);
          khState.pendingPortfolioAction = null;
        })
        .getAMPortfolioAnalysis(amName);
    }
    
    /**
     * Execute team-wide portfolio analysis
     */
    function executeTeamAnalysis() {
      // Remove action buttons if they exist
      const actionButtons = document.querySelector('.kh-action-buttons');
      if (actionButtons) {
        actionButtons.remove();
      }
      
      // Show loading
      khState.isLoading = true;
      if (khEls.sendBtn) khEls.sendBtn.disabled = true;
      const loadingEl = addKHMessage('loading', '');
      
      console.log('[executeTeamAnalysis] Running team-wide analysis');
      
      google.script.run
        .withSuccessHandler((result) => {
          if (loadingEl) loadingEl.remove();
          khState.isLoading = false;
          if (khEls.sendBtn) khEls.sendBtn.disabled = false;
          
          if (result.success) {
            const formattedAnalysis = formatTeamAnalysis(result.data);
            addKHMessage('assistant', formattedAnalysis + `

If you have any other questions about the team data I'd be happy to dive in with you!`);
            
            khState.conversationHistory.push({ 
              role: 'assistant', 
              content: `[Team portfolio data loaded]\n${JSON.stringify(result.data)}` 
            });
          } else {
            addKHMessage('error', 'Could not analyze team: ' + (result.error || 'Unknown error'));
          }
          khState.pendingTeamAnalysisAction = false;
        })
        .withFailureHandler((error) => {
          if (loadingEl) loadingEl.remove();
          khState.isLoading = false;
          if (khEls.sendBtn) khEls.sendBtn.disabled = false;
          addKHMessage('error', 'Error: ' + error.message);
          khState.pendingTeamAnalysisAction = false;
        })
        .getTeamPortfolioAnalysis();
    }
    
    /**
     * Re-run the original query after user navigates to AM tab
     */
    function executeRetryQuery() {
      // Remove action buttons
      const actionButtons = document.querySelector('.kh-action-buttons');
      if (actionButtons) {
        actionButtons.remove();
      }
      
      const queryToRetry = khState.pendingRetryQuery;
      khState.pendingRetryQuery = null;
      
      if (queryToRetry) {
        console.log('[executeRetryQuery] Re-running query: ' + queryToRetry);
        sendKHMessage(queryToRetry);
      }
    }

    /**
     * Switch to a specific tab and retry the query
     */
    function switchAndRetry(tabName) {
      if (!tabName) return;
      
      const loadingEl = addKHMessage('loading', '');
      
      google.script.run
        .withSuccessHandler((result) => {
          if (loadingEl) loadingEl.remove();
          
          if (result.success) {
            // Tab switched successfully, now retry
            executeRetryQuery();
          } else {
            addKHMessage('error', 'Could not switch tab: ' + (result.error || 'Unknown error'));
          }
        })
        .withFailureHandler((error) => {
          if (loadingEl) loadingEl.remove();
          addKHMessage('error', 'Error switching tab: ' + error.message);
        })
        .activateSheet(tabName);
    }

    /**
     * Switch to selected AM tab from dropdown and retry
     */
    function switchAndRetryFromSelect() {
      const select = document.getElementById('kh-am-select');
      if (!select) return;
      
      const tabName = select.value;
      if (!tabName) {
        addKHMessage('error', 'Please select an AM first.');
        return;
      }
      
      switchAndRetry(tabName);
    }
    
    /**
     * Show list of available AMs for selection
     */
    function showAMSelectionList() {
      // Remove existing action buttons
      const actionButtons = document.querySelector('.kh-action-buttons');
      if (actionButtons) {
        actionButtons.remove();
      }
      
      // Check if we already have the list cached
      if (khState.availableAMs && khState.availableAMs.length > 0) {
        renderAMSelectionList(khState.availableAMs);
        return;
      }
      
      // Fetch list from backend
      khState.isLoading = true;
      const loadingEl = addKHMessage('loading', '');
      
      google.script.run
        .withSuccessHandler((result) => {
          if (loadingEl) loadingEl.remove();
          khState.isLoading = false;
          
          if (result.success && result.ams.length > 0) {
            khState.availableAMs = result.ams;
            renderAMSelectionList(result.ams);
          } else {
            addKHMessage('error', 'No AM tabs found in this workbook.');
          }
        })
        .withFailureHandler((error) => {
          if (loadingEl) loadingEl.remove();
          khState.isLoading = false;
          addKHMessage('error', 'Error loading AMs: ' + error.message);
        })
        .getAvailableAMTabs();
    }
    
    /**
     * Render the AM selection list as buttons
     */
    function renderAMSelectionList(ams) {
      let buttonsHtml = '<div class="kh-am-selection"><p style="margin:0 0 8px 0; font-size:11px; color:#64748b;">Select an Account Manager:<\/p>';
      
      ams.forEach(am => {
        const displayName = am.fullName || am.tabName || 'Unknown';
        buttonsHtml += `<button class="kh-action-btn secondary" style="margin:2px; flex:none; width:auto;" onclick="selectAMForAnalysis('${displayName.replace(/'/g, "\\'")}')">
          ${displayName}
        <\/button>`;
      });
      
      buttonsHtml += `<button class="kh-action-btn secondary" style="margin:2px; flex:none; width:auto; background:#f0fdf4; border-color:#86efac;" onclick="executeTeamAnalysis()">
        üë• All AMs (Team)
      <\/button>`;
      
      buttonsHtml += '<\/div>';
      
      addKHMessage('assistant', 'Who would you like to analyze?\n\n' + buttonsHtml);
    }
    
    /**
     * Select a specific AM for analysis (from the list)
     */
    function selectAMForAnalysis(amName) {
      // Set up the pending action and execute
      khState.pendingPortfolioAction = {
        type: 'CONFIRM',
        amName: amName
      };
      executePortfolioAction(true);
    }
    
    /**
     * Format portfolio analysis data for display
     */
    function formatPortfolioAnalysis(data) {
      const formatList = (list, maxItems = 5) => {
        if (!list || list.length === 0) return 'None';
        return list.slice(0, maxItems).map(item => `${item.label} (${item.count})`).join(' | ');
      };
      
      let html = `## üìä Portfolio Analysis: ${data.amName}\n\n`;
      
      html += `**Overview**\n`;
      html += `- **Bucket:** ${data.bucket} accounts | **Groups:** ${data.groups}\n`;
      html += `- **Avg Yield:** $${data.avgYield} | **Avg Sub Fee:** $${data.avgSubFee}\n\n`;
      
      html += `**‚ö†Ô∏è Contract Status** (Priority Items)\n`;
      html += `- **Term Pending:** ${data.termPending}${data.termPending > 0 ? ' ‚ö†Ô∏è' : ''}\n`;
      html += `- Expired: ${data.contractRenewal.expired} | Canceling: ${data.contractRenewal.canceling} | Warning (45d): ${data.contractRenewal.warning45d}\n\n`;
      
      html += `**üìà Product Adoption**\n`;
      html += `- Active PI: ${data.activePI} | Active XP: ${data.activeXP}\n`;
      html += `- Private Dining: ${data.privateDining} | Instant Booking: ${data.instantBooking}\n`;
      html += `- Discovery %: ${data.discoveryPct} | PI Rev Share: ${data.piRevShare}\n\n`;
      
      html += `**System Mix:** ${formatList(data.systemMix)}\n\n`;
      html += `**Quality Tiers:** ${formatList(data.qualityTiers)}\n\n`;
      html += `**Exclusive Pricing:** ${formatList(data.exclusivePricing)}\n\n`;
      html += `**Special Programs:** ${formatList(data.specialPrograms) || 'None'}\n\n`;
      html += `**No Booking Reasons:** ${formatList(data.noBookingReasons) || 'None'}\n\n`;
      
      // Add key observations
      html += `---\n**Key Observations:**\n`;
      
      if (data.termPending > 0) {
        html += `- üî¥ **${data.termPending} Term Pending** accounts need immediate renewal conversations\n`;
      }
      if (data.contractRenewal.expired > 0) {
        html += `- üî¥ **${data.contractRenewal.expired} Expired** contracts - urgent outreach needed\n`;
      }
      if (data.noBookingReasons && data.noBookingReasons.length > 0) {
        const fullbookIssue = data.noBookingReasons.find(r => r.label.toLowerCase().includes('fullbook'));
        if (fullbookIssue) {
          html += `- ‚ö†Ô∏è **${fullbookIssue.count} accounts** with Fullbook issues - check for system problems\n`;
        }
      }
      if (data.termPending === 0 && data.contractRenewal.expired === 0) {
        html += `- ‚úÖ No urgent contract issues\n`;
      }
      
      html += `\nWould you like me to dive deeper into any of these areas?`;
      
      return html;
    }
    
    /**
     * Format team analysis data for display
     */
    function formatTeamAnalysis(data) {
      const formatList = (list, maxItems = 5) => {
        if (!list || list.length === 0) return 'None';
        return list.slice(0, maxItems).map(item => `${item.label} (${item.count})`).join(' | ');
      };
      
      let html = `## üë• Team Portfolio Analysis\n\n`;
      
      html += `**Overview** (${data.amCount} Account Managers)\n`;
      html += `- **Total Bucket:** ${data.bucket} accounts | **Groups:** ${data.groups}\n`;
      html += `- **Avg Yield:** $${data.avgYield} | **Avg Sub Fee:** $${data.avgSubFee}\n\n`;
      
      html += `**‚ö†Ô∏è Contract Status** (Team-wide)\n`;
      html += `- **Term Pending:** ${data.termPending}${data.termPending > 0 ? ' ‚ö†Ô∏è' : ''}\n`;
      html += `- Expired: ${data.contractRenewal.expired} | Canceling: ${data.contractRenewal.canceling} | Warning (45d): ${data.contractRenewal.warning45d}\n\n`;
      
      html += `**üìà Product Adoption**\n`;
      html += `- Active PI: ${data.activePI} | Active XP: ${data.activeXP}\n`;
      html += `- Private Dining: ${data.privateDining} | Instant Booking: ${data.instantBooking}\n\n`;
      
      html += `**System Mix:** ${formatList(data.systemMix)}\n\n`;
      html += `**Quality Tiers:** ${formatList(data.qualityTiers)}\n\n`;
      html += `**Exclusive Pricing:** ${formatList(data.exclusivePricing)}\n\n`;
      
      // AM Breakdown
      if (data.amBreakdown && data.amBreakdown.length > 0) {
        html += `**AM Breakdown** (by bucket size):\n`;
        data.amBreakdown.slice(0, 10).forEach(am => {
          const flag = am.termPending > 0 ? ` ‚ö†Ô∏è${am.termPending}` : '';
          html += `- ${am.name}: ${am.bucket} accts${flag}\n`;
        });
        html += `\n`;
      }
      
      html += `Would you like to see details for a specific AM?`;
      
      return html;
    }
    
    /**
     * Initialize AM context on chat open
     * Called when the chat panel opens to detect current AM tab
     */
    function initAMContext() {
      // Show loading banner
      const banner = document.getElementById('khDataBanner');
      if (banner) banner.style.display = 'flex';
      
      google.script.run
        .withSuccessHandler((result) => {
          khState.currentAMContext = result;
          console.log('[initAMContext] AM Context:', result);
          
          // If on AM tab, pre-fetch portfolio data for faster chat responses
          if (result.isAMTab && result.fullName) {
            prefetchAMData(result.fullName);
          } else {
            // Not on AM tab, hide banner
            if (banner) banner.style.display = 'none';
          }
        })
        .withFailureHandler((error) => {
          console.log('[initAMContext] Error:', error.message);
          const banner = document.getElementById('khDataBanner');
          if (banner) banner.style.display = 'none';
        })
        .getActiveAMContext();
    }
    
    /**
     * Pre-fetch AM portfolio data in background for faster chat responses
     * Called after initAMContext detects an AM tab
     * @param {string} amName - The AM's full name
     */
    function prefetchAMData(amName) {
      console.log('[prefetchAMData] Pre-fetching data for:', amName);
      
      // Store AM name for refresh functionality
      khState.currentAMName = amName;
      
      google.script.run
        .withSuccessHandler((data) => {
          if (data && data.success) {
            khState.cachedAMData = data;
            khState.cachedAMDataExpiry = Date.now() + 1800000; // 30 min expiry
            khState.cachedAMDataTime = new Date(); // Track when data was fetched
            console.log('[prefetchAMData] Cached', data.totalAccounts, 'accounts for', amName);
            
            // Show "Data Loaded" banner with timestamp
            showDataLoadedBanner();
          } else {
            console.log('[prefetchAMData] No data returned or error');
          }
          // Hide loading banner
          const banner = document.getElementById('khDataBanner');
          if (banner) banner.style.display = 'none';
        })
        .withFailureHandler((error) => {
          console.log('[prefetchAMData] Error:', error.message);
          const banner = document.getElementById('khDataBanner');
          if (banner) banner.style.display = 'none';
        })
        .getDetailedAMData(amName);
    }
    
    /**
     * Show the "Data Loaded" banner with timestamp
     */
    function showDataLoadedBanner() {
      const loadedBanner = document.getElementById('khDataLoadedBanner');
      const timestampEl = document.getElementById('khDataTimestamp');
      
      if (loadedBanner && timestampEl && khState.cachedAMDataTime) {
        const time = khState.cachedAMDataTime;
        const hours = time.getHours().toString().padStart(2, '0');
        const mins = time.getMinutes().toString().padStart(2, '0');
        timestampEl.textContent = `${hours}:${mins}`;
        loadedBanner.style.display = 'flex';
      }
    }
    
    /**
     * Refresh AM data - clears cache and re-fetches
     * Called by the refresh button in the "Data Loaded" banner
     */
    function refreshAMData() {
      const amName = khState.currentAMName || (khState.currentAMContext && khState.currentAMContext.fullName);
      
      if (!amName) {
        console.log('[refreshAMData] No AM name available');
        return;
      }
      
      // Clear cached data
      khState.cachedAMData = null;
      khState.cachedAMDataExpiry = 0;
      khState.cachedAMDataTime = null;
      
      // Hide "Data Loaded" banner, show loading banner
      const loadedBanner = document.getElementById('khDataLoadedBanner');
      const loadingBanner = document.getElementById('khDataBanner');
      if (loadedBanner) loadedBanner.style.display = 'none';
      if (loadingBanner) loadingBanner.style.display = 'flex';
      
      // Disable refresh button during fetch
      const refreshBtn = document.querySelector('.kh-refresh-btn');
      if (refreshBtn) refreshBtn.disabled = true;
      
      console.log('[refreshAMData] Refreshing data for:', amName);
      
      // Re-fetch data
      google.script.run
        .withSuccessHandler((data) => {
          if (data && data.success) {
            khState.cachedAMData = data;
            khState.cachedAMDataExpiry = Date.now() + 1800000; // 30 min expiry
            khState.cachedAMDataTime = new Date();
            console.log('[refreshAMData] Refreshed', data.totalAccounts, 'accounts');
            showDataLoadedBanner();
          }
          if (loadingBanner) loadingBanner.style.display = 'none';
          if (refreshBtn) refreshBtn.disabled = false;
        })
        .withFailureHandler((error) => {
          console.log('[refreshAMData] Error:', error.message);
          if (loadingBanner) loadingBanner.style.display = 'none';
          if (refreshBtn) refreshBtn.disabled = false;
        })
        .getDetailedAMData(amName);
    }

    function submitKHFeedback(msgId, rating) {
      const msgEl = document.getElementById(msgId);
      if (!msgEl) return;
      
      const feedbackBtns = msgEl.querySelectorAll('.kh-feedback-btn');
      const feedbackText = msgEl.querySelector('.kh-feedback-text');
      
      // Disable buttons
      feedbackBtns.forEach(btn => btn.disabled = true);
      
      // Highlight selected
      feedbackBtns[rating === 'helpful' ? 0 : 1].classList.add(
        rating === 'helpful' ? 'active-helpful' : 'active-not-helpful'
      );
      
      // Send feedback
      google.script.run
        .withSuccessHandler((result) => {
          if (feedbackText) {
            feedbackText.textContent = result.success ? 'Thanks!' : 'Error';
          }
        })
        .withFailureHandler(() => {
          if (feedbackText) feedbackText.textContent = 'Error';
        })
        .logKnowledgeHubFeedback({
          query: msgEl.dataset.query || '',
          response: msgEl.dataset.response || '',
          rating: rating
        });
    }

    function openKHCorrection(msgId) {
      const msgEl = document.getElementById(msgId);
      if (!msgEl) return;
      
      const modal = document.getElementById('khCorrectionModal');
      const preview = document.getElementById('khCorrectionPreview');
      const textarea = document.getElementById('khCorrectionText');
      
      if (modal && preview && textarea) {
        preview.textContent = (msgEl.dataset.response || '').substring(0, 200) + '...';
        textarea.value = '';
        modal.dataset.msgId = msgId;
        modal.classList.add('open');
        textarea.focus();
      }
    }

    function closeKHCorrection() {
      const modal = document.getElementById('khCorrectionModal');
      if (modal) modal.classList.remove('open');
    }

    /**
     * Copy RID to clipboard and show toast notification
     * @param {string} rid - Restaurant ID to copy
     */
    function copyRIDToClipboard(rid) {
      navigator.clipboard.writeText(rid).then(() => {
        const toast = document.getElementById('khToast');
        if (toast) {
          toast.textContent = `RID ${rid} copied to clipboard`;
          toast.classList.add('show');
          setTimeout(() => toast.classList.remove('show'), 2000);
        }
      }).catch(err => {
        console.error('[copyRIDToClipboard] Failed to copy:', err);
      });
    }

    /**
     * Show the help guide modal
     */
    function showHelpGuide() {
      const modal = document.getElementById('helpModal');
      if (modal) modal.classList.add('open');
    }
    
    /**
     * Close the help guide modal
     */
    function closeHelpModal() {
      const modal = document.getElementById('helpModal');
      if (modal) modal.classList.remove('open');
    }

    function submitKHCorrection() {
      const modal = document.getElementById('khCorrectionModal');
      const textarea = document.getElementById('khCorrectionText');
      const submitBtn = document.getElementById('khCorrectionSubmit');
      
      if (!modal || !textarea) return;
      
      const correction = textarea.value.trim();
      if (!correction) return;
      
      const msgId = modal.dataset.msgId;
      const msgEl = document.getElementById(msgId);
      
      if (submitBtn) submitBtn.disabled = true;
      
      google.script.run
        .withSuccessHandler((result) => {
          if (submitBtn) submitBtn.disabled = false;
          closeKHCorrection();
          
          // Update feedback text on original message
          if (msgEl) {
            const feedbackText = msgEl.querySelector('.kh-feedback-text');
            if (feedbackText) feedbackText.textContent = result.success ? 'Correction submitted!' : 'Error';
          }
        })
        .withFailureHandler(() => {
          if (submitBtn) submitBtn.disabled = false;
          alert('Failed to submit correction');
        })
        .logKnowledgeHubFeedback({
          query: msgEl ? msgEl.dataset.query : '',
          response: msgEl ? msgEl.dataset.response : '',
          rating: 'not_helpful',
          correction: correction
        });
    }

    function formatKHResponse(text) {
      // Escape HTML first
      let html = text
        .replace(/&/g, '&amp;')
        .replace(/<\/g, '&lt;')
        .replace(/>/g, '&gt;');
      
      // Headers: ### text, ## text, # text ‚Üí styled headers
      html = html.replace(/^### (.+)$/gm, '<div class="kh-header kh-h3">$1<\/div>');
      html = html.replace(/^## (.+)$/gm, '<div class="kh-header kh-h2">$1<\/div>');
      html = html.replace(/^# (.+)$/gm, '<div class="kh-header kh-h1">$1<\/div>');
      
      // Horizontal rules: --- ‚Üí styled divider
      html = html.replace(/^---+$/gm, '<hr class="kh-divider">');
      
      // Bold: **text** or __text__
      html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1<\/strong>');
      html = html.replace(/__(.+?)__/g, '<strong>$1<\/strong>');
      
      // Inline code: `code`
      html = html.replace(/`([^`]+)`/g, '<code>$1<\/code>');
      
      // Markdown tables - MUST process BEFORE line breaks
      // Match table blocks: lines starting with |
      html = html.replace(/(?:^|\n)(\|[^\n]+\|\n\|[-:\|\s]+\|\n(?:\|[^\n]+\|\n?)+)/g, function(match) {
        const lines = match.trim().split('\n').filter(line => line.trim());
        if (lines.length < 2) return match;
        
        // First line is header
        const headerCells = lines[0].split('|').filter(cell => cell.trim() !== '');
        
        // Skip separator line (line with dashes)
        // Rest are data rows
        const dataLines = lines.slice(2);
        
        let tableHtml = '<table class="kh-table"><thead><tr>';
        headerCells.forEach(cell => {
          tableHtml += '<th>' + cell.trim() + '<\/th>';
        });
        tableHtml += '<\/tr><\/thead><tbody>';
        
        dataLines.forEach(line => {
          const cells = line.split('|').filter(cell => cell.trim() !== '');
          tableHtml += '<tr>';
          cells.forEach(cell => {
            tableHtml += '<td>' + cell.trim() + '<\/td>';
          });
          tableHtml += '<\/tr>';
        });
        
        tableHtml += '<\/tbody><\/table>';
        return '\n' + tableHtml + '\n';
      });
      
      // Line breaks
      html = html.replace(/\n/g, '<br>');
      
      // Simple bullet lists (lines starting with - or *)
      html = html.replace(/<br>[\s]*[-*]\s+/g, '<br>‚Ä¢ ');
      
      // Numbered lists
      html = html.replace(/<br>(\d+)\.\s+/g, '<br>$1. ');
      
      // Make account names clickable to copy RID
      // Sort by name length (longest first) to avoid partial matches
      const sortedNames = Object.keys(ACCOUNT_NAME_TO_RID).sort((a, b) => b.length - a.length);
      sortedNames.forEach(name => {
        if (name.length < 4) return; // Skip very short names to avoid false matches
        const rid = ACCOUNT_NAME_TO_RID[name];
        // Escape special regex characters in name
        const escapedName = name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        // Match whole word boundaries, case-insensitive
        const regex = new RegExp(`\\b${escapedName}\\b`, 'gi');
        html = html.replace(regex, `<span class="kh-clickable-account" data-rid="${rid}" onclick="copyRIDToClipboard('${rid}')" onmouseenter="showCustomTooltip(this, 'Click to copy RID: ${rid}')" onmouseleave="hideCustomTooltip()">${name}<\/span>`);
      });

      return html;
    }

    // #region agent log
    console.log('[DEBUG-G] BI_Script2.html script block FULLY PARSED - registering event listeners');
    // #endregion
    // Initialize Knowledge Hub when page loads
    document.addEventListener('DOMContentLoaded', initKnowledgeHub);
    // Also try on window load as fallback
    window.addEventListener('load', initKnowledgeHub);
  </script>
